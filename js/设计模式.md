# JS设计模式

## 设计模式原则

## 概览

| 名称         | 分类   |                                |      |
| ------------ | ------ | ------------------------------ | ---- |
| 单例模式     | 创建型 | 一个类只能构造出唯一实例       |      |
| 原型模式     | 创建型 |                                |      |
| 工厂模式     | 创建型 |                                |      |
| 抽象工厂模式 | 创建型 |                                |      |
| 建造者模式   | 创建型 |                                |      |
| 适配器模式   | 结构型 |                                |      |
| 装饰器模式   |        |                                |      |
| 代理模式     |        |                                |      |
| 外观模式     |        |                                |      |
| 桥接模式     |        |                                |      |
| 组合模式     |        |                                |      |
| 享元模式     | 结构型 |                                |      |
| 观察者模式   | 行为型 |                                |      |
| 迭代器模式   |        |                                |      |
| 策略模式     |        | 将算法的使用和算法的实现分离开 |      |
| 模板方法模式 |        |                                |      |
| 职责链模式   |        |                                |      |
| 命令模式     |        |                                |      |
| 备忘录模式   |        |                                |      |
| 状态模式     |        |                                |      |
| 访问者模式   |        |                                |      |
| 中介者模式   |        |                                |      |
| 解释器模式   |        |                                |      |



### 订阅/发布模式（观察者模式）

~~一个对象订阅另外一个对象的特定活动，并在状态改变后获得通知。订阅者因此也成为观察者，而被观察的对象成为发布者，当发生特定活动的时候，发布者会通知所有的订阅者~~

定义了一种一对多的关系，让多个观察者对象同时监听某一个主体对象，这个主体对象的状态发生变化的时候，就会通知所有的订阅者，使它能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。

发布/订阅

一对多

适用场景

案例  Vue $emit $on

```javascript
// 主题对象 保存状态 ，保存观察者，状态变化之后触发所有的观察者对象
class Sub {
  constructor() {
    this.state = 0
    this.observers = []
  }
  getState() {
    return this.state
  }
  setState(state) {
    this.state = state
    this.notify()
  }
  notify() {
    this.observers.forEach(observer => {
      observer.update()
    })
  }
  attach(obs) {
    this.observers.push(obs)
  }
}
// 观察者
class Observer {
  constructor(name, sub) {
    this.name = name
    this.sub = sub
    this.sub.attach(this)
  }
  update() {
    console.log(`${this.name} update , state:${this.sub.getState()}`);
  }
}

let sub = new Sub()
let ob1 = new Observer('ob1', sub)
let ob2 = new Observer('ob2', sub)
sub.setState(12)
```

事件侦听

```javascript
class Event {
  constructor() {
    this.callbacks = {}
  }
  $off(name) {
    this.callbacks[name] = null
  }
  $emit(name, args) {
    let cbs = this.callbacks[name]
    if (cbs) {
      cbs.forEach(cb => {
        // cb && cb(args)
        cb.call(this, args)
      })
    }
  }
  $on(name, callback) {
    (this.callbacks[name] || (this.callbacks[name] = [])).push(callback)
  }
}
// 观察者模式
let event = new Event()
event.$on('event1', function (arg) {
  console.log('event1', arg)
})

event.$on('event1', function (arg) {
  console.log('又一个事件1', arg)
})

event.$on('event2', function (arg) {
  console.log('event2', arg)
})

event.$emit('event1', '触发侦听的事件1')
event.$emit('event2', '触发侦听的事件2')

event.$off('event1')
event.$emit('event1', 'event1事件侦听被干掉了')

```



### 单例模式

确保一个类仅有一个实例，并提供一个访问它的全局访问点，实现的方法为判断实例是否存在，存在直接返回当前实例，不存在就创建新的实例返回。

适用场景  弹窗 loading  登录框  vuex和redux中的store

案例  elementUI 弹窗

```javascript
// loading
class Loading {
  constructor() {
    this.state = 'hide'
  }
  show() {
    if(this.state === 'show'){
      console.log('已经显示')
      return
    }
    this.state = 'show'
  }
  hide(){
    if(this.state === 'hide'){
      console.log('已经隐藏')
      return
    }
  }
}
Loading.createInstance = (function() {
  let loadingInstance = null
  return function(){
    return loadingInstance || (loadingInstance = new Loading())
  }
})()

let loading1 = Loading.createInstance()
loading1.show()
let loading2 = Loading.createInstance()
loading2.hide()
console.log(loading1 === loading2)
```

```javascript
// 单例模式创建弹窗
var getSingle = function (fn) {
  var result
  return function () {
    return result || (result = fn.apply(this, arguments))
  }
}
var createLoginLayer = function () {
  // var d = document.createDocumentFragment()
  var box = document.createElement('div')
  box.innerHTML = '我是个弹窗'
  box.style.display = 'none'
  document.body.appendChild(box)
  return box
}
var createSingleLoginLayer = getSingle(createLoginLayer)
document.getElementById('loginBtn').onclick = function () {
  var loginLayer = createSingleLoginLayer()
  loginLayer.style.display = 'block'
}
```



### 策略模式

定义：定义一系列的算法，把他们一个个封装起来，并且是他们可以相互替换

说人话：策略模式的目的就是将算法的使用和算法的实现分离开。一个基于策略模式的程序至少有两部分组成，一部分是（可变）策略类，封装了具体的算法，并负责具体的计算过程；第二个部分是（不可变）坏境类Context，COntext接受客户的请求，随后将请求委托给某一个策略类。要做到

使用场景 

如果一个系统里面有许多类，他们之间的区别仅在于他们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。

一个系统需要动态地在几种算法中选择一种

表单校验

案例

奖金计算：奖⾦金金计算，绩效为 S 的⼈人年年 终奖有 4 倍⼯工资，绩效为 A 的⼈人年年终奖有 3 倍⼯工资，⽽而绩效为 B 的⼈人年年终 奖是 2 倍⼯工资

普通写法

```javascript
var calculateBonus = function(perfomanceLevel, salary) {
  if(perfomanceLevel === 'S'){
    return salary * 4
  }else if(perfomanceLevel === 'A'){
    return salary * 3
  }else if(perfomanceLevel === "B"){
    return salary * 2
  }
}
console.log(calculateBonus('S', 10000))
 
```

策略模式

```javascript
var strategies = {
  S: function(salary) {
    return salary * 4
  },
  A: function(salary) {
    return salary * 3
  },
  B: function(salary) {
    return salary * 2
  }
}
var calculateBonus = function(level, salary) {
  return strategies[level](salary)
}
console.log(calculateBonus('S', 10000))
```

表单验证

```

```



### 代理模式

为一个对象提供一个代理品或占位符，以便控制对它的访问。

适用场景：花销很大的操作，可以通过虚拟代理的方式，延迟到需要它的时候才去创建，例如虚拟代理实现图片懒加载。

收集一段实践内的请求，一次性发送给给服务器。

### 中介者模式



### 装饰器模式

在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法

适用场景

案例 react的高阶组件 ，react-redux中的@connect

### 外观模式

外观模式即让多个方法一起被调用，

涉及到兼容性，参数支持多格式，对外暴露统一的api,对内只用一个函数，内部判断实现

### 工厂模式

提供创建对象的接口，把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合。

案例 弹窗 message

### 建造者模式

参与了更多创建的过程，或者更复杂

### 迭代器模式

### 享元模式

### 职责链模式

### 适配器模式

### 模式方法模式

备忘录模式