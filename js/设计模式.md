# JS设计模式

## 设计模式简介

设计模式是为了解决在开发中可能遇到的需求相似，而提出的一套解决办法，其根本目的是减少项目变化所导致的影响

### 常用设计模式

工厂模式 单例模式 命令模式 模板模式 策略模式 观察者模式  命名空间模式

### 设计模式原则

### 设计模式目的

高内聚，低耦合；提高重用性，减少代码冗余；扩展性，稳定性；



## 概览

| 名称         | 分类   |                                                              |      |
| ------------ | ------ | ------------------------------------------------------------ | ---- |
| 单例模式     | 创建型 | 一个类只能构造出唯一实例                                     |      |
| 原型模式     | 创建型 |                                                              |      |
| 工厂模式     | 创建型 |                                                              |      |
| 抽象工厂模式 | 创建型 |                                                              |      |
| 建造者模式   | 创建型 |                                                              |      |
| 适配器模式   | 结构型 | 一个类转化为另一个类（另一个类的属性存储第一个类的实例），一种数据结构转化为另一种数据结构 （适配是存原类一个实例改方法结果，装饰器是接收原类的实例加方法） |      |
| 装饰器模式   |        |                                                              |      |
| 代理模式     |        |                                                              |      |
| 外观模式     |        |                                                              |      |
| 桥接模式     |        |                                                              |      |
| 组合模式     |        |                                                              |      |
| 享元模式     | 结构型 |                                                              |      |
| 观察者模式   | 行为型 |                                                              |      |
| 迭代器模式   |        |                                                              |      |
| 策略模式     |        | 将算法的使用和算法的实现分离开，根据参数可以命中不同策略     |      |
| 模板方法模式 |        |                                                              |      |
| 职责链模式   |        |                                                              |      |
| 命令模式     |        |                                                              |      |
| 备忘录模式   |        |                                                              |      |
| 状态模式     |        |                                                              |      |
| 访问者模式   |        |                                                              |      |
| 中介者模式   |        |                                                              |      |
| 解释器模式   |        |                                                              |      |



### 订阅/发布模式（观察者模式）

~~一个对象订阅另外一个对象的特定活动，并在状态改变后获得通知。订阅者因此也成为观察者，而被观察的对象成为发布者，当发生特定活动的时候，发布者会通知所有的订阅者~~

定义了一种一对多的关系，让多个观察者对象同时监听某一个主体对象，这个主体对象的状态发生变化的时候，就会通知所有的订阅者，使它能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。

发布/订阅

有人发布，有人订阅，还可以取消订阅，一旦有人发布，订阅者就可以收到消息，主动权在发布者手中。

一对多

适用场景

案例  Vue $emit $on

```javascript
// 主题对象 保存状态 ，保存观察者，状态变化之后触发所有的观察者对象
class Sub {
  constructor() {
    this.state = 0
    this.observers = []
  }
  getState() {
    return this.state
  }
  setState(state) {
    this.state = state
    this.notify()
  }
  notify() {
    this.observers.forEach(observer => {
      observer.update()
    })
  }
  attach(obs) {
    this.observers.push(obs)
  }
}
// 观察者
class Observer {
  constructor(name, sub) {
    this.name = name
    this.sub = sub
    this.sub.attach(this)
  }
  update() {
    console.log(`${this.name} update , state:${this.sub.getState()}`);
  }
}

let sub = new Sub()
let ob1 = new Observer('ob1', sub)
let ob2 = new Observer('ob2', sub)
sub.setState(12)
```

事件侦听

```javascript
class Event {
  constructor() {
    this.callbacks = {}
  }
  $off(name) {
    this.callbacks[name] = null
  }
  $emit(name, args) {
    let cbs = this.callbacks[name]
    if (cbs) {
      cbs.forEach(cb => {
        // cb && cb(args)
        cb.call(this, args)
      })
    }
  }
  $on(name, callback) {
    (this.callbacks[name] || (this.callbacks[name] = [])).push(callback)
  }
}
// 观察者模式
let event = new Event()
event.$on('event1', function (arg) {
  console.log('event1', arg)
})

event.$on('event1', function (arg) {
  console.log('又一个事件1', arg)
})

event.$on('event2', function (arg) {
  console.log('event2', arg)
})

event.$emit('event1', '触发侦听的事件1')
event.$emit('event2', '触发侦听的事件2')

event.$off('event1')
event.$emit('event1', 'event1事件侦听被干掉了')

```



### 单例模式

确保一个类仅有一个实例，并提供一个访问它的全局访问点，实现的方法为判断实例是否存在，存在直接返回当前实例，不存在就创建新的实例返回。

适用场景  弹窗 loading  登录框  vuex和redux中的store

案例  elementUI 弹窗

```javascript
// loading
class Loading {
  constructor() {
    this.state = 'hide'
  }
  show() {
    if(this.state === 'show'){
      console.log('已经显示')
      return
    }
    this.state = 'show'
  }
  hide(){
    if(this.state === 'hide'){
      console.log('已经隐藏')
      return
    }
  }
}
Loading.createInstance = (function() {
  let loadingInstance = null
  return function(){
    return loadingInstance || (loadingInstance = new Loading())
  }
})()

let loading1 = Loading.createInstance()
loading1.show()
let loading2 = Loading.createInstance()
loading2.hide()
console.log(loading1 === loading2)
```

```javascript
// 单例模式创建弹窗
var getSingle = function (fn) {
  var result
  return function () {
    return result || (result = fn.apply(this, arguments))
  }
}
var createLoginLayer = function () {
  // var d = document.createDocumentFragment()
  var box = document.createElement('div')
  box.innerHTML = '我是个弹窗'
  box.style.display = 'none'
  document.body.appendChild(box)
  return box
}
var createSingleLoginLayer = getSingle(createLoginLayer)
document.getElementById('loginBtn').onclick = function () {
  var loginLayer = createSingleLoginLayer()
  loginLayer.style.display = 'block'
}
```



### 策略模式

定义：定义一系列的算法，把他们一个个封装成函数，也可以统一封装进一个对象，然后再定义一个方法，该方法可根据参数

说人话：策略模式的目的就是将**算法的使用**和**算法的实现**分离开。一个基于策略模式的程序至少有两部分组成，一部分是（可变）策略类，封装了具体的算法，并负责具体的计算过程；第二个部分是（不可变）坏境类Context，Context接受客户的请求，随后将请求委托给某一个策略类。

应用场景 

如果一个系统里面有许多类，他们之间的区别仅在于他们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。

一个系统需要动态地在几种算法中选择一种

案例

奖金计算：奖⾦金金计算，绩效为 S 的⼈人年年 终奖有 4 倍⼯工资，绩效为 A 的⼈人年年终奖有 3 倍⼯工资，⽽而绩效为 B 的⼈人年年终 奖是 2 倍⼯工资

普通写法

```javascript
var calculateBonus = function(perfomanceLevel, salary) {
  if(perfomanceLevel === 'S'){
    return salary * 4
  }else if(perfomanceLevel === 'A'){
    return salary * 3
  }else if(perfomanceLevel === "B"){
    return salary * 2
  }
}
console.log(calculateBonus('S', 10000))
 
```

策略模式

```javascript
var strategies = {
  S: function(salary) {
    return salary * 4
  },
  A: function(salary) {
    return salary * 3
  },
  B: function(salary) {
    return salary * 2
  }
}
var calculateBonus = function(level, salary) {
  return strategies[level](salary)
}
console.log(calculateBonus('S', 10000))
```

表单验证

```

```

小球运动

一个小球从A点运动到B点，运动效果可以有很多种，例如快进快出，慢进快出，线性运动...

### 代理模式

为一个对象提供一个代理品或占位符，以便控制对它的访问。

适用场景：花销很大的操作，可以通过虚拟代理的方式，延迟到需要它的时候才去创建，例如虚拟代理实现图片懒加载。

收集一段实践内的请求，一次性发送给给服务器。

### 中介者模式



### 装饰器模式

动态的给对象添加一些额外的方法，是一种实现继承的替代方式。

在不改变原对象的基础上，通过对其进行包装扩展，在程序运行期间给对象动态地添加方法，使原有对象能满足更复杂的要求，而又不影响原对象派生的其他对象

适用场景

案例 react的高阶组件 ，react-redux中的@connect

```javascript
// 装饰器模式
class Developer {
  init() {
    console.log('我是前端开发')
  }
}

class Decorator {
  constructor(developer) {
    this.developer = developer
  }
  init() {
    this.developer.init()
    this.add(this.developer)
  }
  add() {
    console.log('传授你后台之道')
  }
}

// 安静的写前端
var dep = new Developer()
console.log(dep.init())

// 前端架构之路
var d = new Decorator(dep)
console.log(d.init())
```

```javascript
const withLog = Component => {
  class NewComponent extends React.Component{
    //  16.4 shouldReceiveProps shouldUpdate componentUpdate
    // 
    componentWillMount() {
      console.time(`ComponentRender`)
    }
    render() {
      return <Component>{ ...this.props }</Component>
    }
    componentDidMount() {
      console.time(`componentRenderEnd`)
    }
  }
  return NewComponent
}

@withLog
class XX
```

```javascript
// 装饰器模式  原型链方法
Function.prototype.before = function(beforefn) {
  var _self = this // 保存原函数的引用
  return function() { // 返回包含原函数和新函数的 装饰函数
    beforefn.apply(this, arguments) // 执行新函数，且保证 this 不被劫持，新函数接收的参数，也会元丰不动地传入原函数，新韩淑在原函数之前执行
    return _self.apply(this, arguments) // z执行原函数，并返回原函数的执行结果，并保证this不被劫持
  }
}
Function.prototype.after = function(afterfn) {
  var _self = this
  return function() {
    var ret = _self.apply(this, arguments)
    afterfn.apply(this, arguments)
    return ret
  }
}
// 使用装饰器
var showLogin = function(){
  console.log('打开登录框')
}
var log = function(){
  console.log('上报日志')
}
var dicoratorShowlogin = showLogin.after(log)
```

**不同**

装饰器模式和代理模式

- 相同点：都描述了怎样为对象提供一定程度上的间接引用，他们的实现部分都保留了对原对象的引用，并且向元对象发送请求。

- 区别：代理模式的目的是，直接访问本体不方便或者不符合需求时，这时为本地提供一个替代者，本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。
  - 装饰器模式的作用就帅为对象动态加入行为，不影响不改变原对象再生成的实例

### 外观模式

外观模式即让多个方法一起被调用，定义了一个高层接口，这个接口使

涉及到兼容性，参数支持多格式，对外暴露统一的api,对内只用一个函数，内部判断实现

**应用场景**

```
let addEvent 
```



### 工厂模式

es5：提供创建对象的接口，把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合。

es6：工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类，该模式试一个类的实例化延迟到了子类，而子类可以重写接口方法以便创建的时候指定自己的对象类型。

- **简单工厂模式**

给定不同的材料，生成不同属性值的产品，并把产品返回；批量生产，具备相同属性的产品。

步骤

1. 声明工厂函数（接收原材料），创建对象，设置对象属性，返回对象
2. 使用工厂函数，传递参数，接收对象

- **复杂工厂模式**

  可以根据不同的**类型**和**原材料**，创建不同的产品

   步骤

1. 声明工厂函数（可以根据需求，自己添加相关工厂属性）
2. 让工厂具备两个能力：根据不同的类型（type）和原材料，找到生产线，生成产品并返回；扩展生产线的能力
3. 根据需求扩展生产线
4. 用户开始使用

**应用场景**

需要创建的对象较少，客户端不关心对象的创建过程

es6

```javascript
class Procuct {
  constructor(name) {
    this.name = name
  }
  init() {
    console.log('init')
  }
  fun() {
    console.log('fun')
  }
}

class Factory {
  create(name) {
    return new Procuct(name)
  }
}
var factory = new Factory()
var p1 = factory.create('p1')
p1.init()
p1.fun()
```

**应用场景**

- 不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选，那么工厂模式是一个理想的选择

- 将new操作简单封装，当遇到new操作时，就应该考虑是否使用工厂模式
- 需要依赖具体坏境创建不同实例，这些实例都有相同的行为

**优点**

- 创建对象的过程可能很复杂，但我们只需要关系创建的结果
- 构造函数和创建者分类，符合“开闭原则”
- 一个调用者想创建一个对象，只需要知道其名称就可以了。
- 扩展性搞，如果想增加一个产品，只要扩展一个工厂类就可以

**缺点**

- 添加新产品时，需要编写新的具体产品类，一定程度上增加了系统的复杂度
- 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度



**案例**

 弹窗 message  

网页Token存储 在浏览器支持H5的时候，存储于localStorage，在不支持H5的浏览器中存于cookie

### 建造者模式

参与了更多创建的过程，或者更复杂

```javascript
// 建造者模式
var Person = function(name, work) {
  // 创建应聘者缓存对象
  var _person = new Human()
  // 创建应聘者姓名解析对象
  _person.name = new NamedNodeMap(name)
  // 创建应聘者期望职位
  _person.work = new Worker(work)
  return _person
}

var person = new Person('xiaobai', 'desgin')
console.log(person)
```



### 迭代器模式

### 享元模式

### 职责链模式

### 适配器模式

适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能

将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容的问题通过适配器得以解决。

**优点**

可以让两个没有任何关联的类一起运行，提高了类的复用，适配对象，适配库，适配数据。（不能修改原对象，又需要复用，新增的时候）

**缺点**

- 额外对象的创建，非直接调用，存在一定的开销
- 如果没有必要使用适配器模式，可以考虑重构

**应用场景**

- 整合第三方SDK

- 封装旧接口

- vue中的computed

  原有数据并没有改变，只改变了原有数据的表现形式
  
  ```javascript
  var aisMap = {
    show: function() {
    }
  }
  var baiduMap = {
    display: function() {
  
    }
  }
  
  var adapterBaiduMap = {
    show: function() {
      return baiduMap.display()
    }
  }
  console.log(aisMap.show(), adapterBaiduMap.show())
  ```
  
  

```javascript
class Base {
  getName() {
    return 'base'
  }
}

class Adapter {
  constructor() {
    this.base = new Base()
  }
  getName() {
    return this.base.getName() + '适配后'
  }
}

let adapter = new Adapter()
console.log(adapter.getName())
```

**适配器与代理模式区别**

- 适配器模式提供一个不同的接口
- 代理模式 提供一模一样的接口

#### 适配器模式 装饰器模式 代理模式 外观模式

适配器模式主要用来解决两个已有接口之间不匹配的问题，不考虑接口是如何实现的，也不考虑将来会如何演化，适配器模式不改变原来的接口，使它们协同作用。

装饰器模式和代理模式也不会改变原有对象的接口，但装饰器模式的作用是为了给对象增加功能，装饰器模式通常形成一条长的装饰链，

适配器模式通常只包装一次。

代理模式是为了控制对**对象**的访问，通常也只包装一次。

### 模式方法模式

> 模板方法模式再一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中。模板方法模式使得子类可以再不改变算法结构的情况下，重新定义算法中某些步骤的具体实现。

应用场景

流程步骤都是一模一样，只是部分细节不同，此时可以在父类型定义这个模板，封装这些固定的操作，子类重写部分方法

案例

vue中的slot， react中的children

### 备忘录模式

可以恢复到对象之前的某个状态。

提供一个全局的对象（缓存对象），当我们传递参数需要进行计算的时候i，先检查缓存对象中是否有对应的结果。如果有缓存数据，那么就直接使用。如果没有缓存数据，那么再执行这个计算操作，处理得到的结果之后，把这个数据保存起来。

案例

react或者redux的，时间旅行的功能，就算是备忘模式的一个应用。

### 命令模式

降低对象之间的耦合度，新的命令可以很容易的加入到系统中，调用同一方法实现不同的功能

