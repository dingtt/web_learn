## 执行上下文

执行上下文时执行JavaScript代码的环境的抽象概念

### 类型

全局执行上下文：

执行创建window对象，设置this

函数执行上下文

调用函数时创建，可以有多个。

### 调用栈

即执行栈，后进先出，用来存储代码运行时创建的所有执行上下文。

创建全局执行上下文入栈；创建函数执行上下午入栈，函数执行完出栈。

### 创建执行上下文

this值的决定，（全局，引用对象调用，）

#### 创建词法环境

词法环境是一种持有标识符和变量映射的接口，标识符指变量名，变量的实际对象或原始数据的引用。

**两个组件**

1. **环境记录器**是存储变量和函数声明的实际位置。
2. **外部环境的引用**意味着它可以访问其父级词法环境（作用域）

**两种类型**

**全局词法环境**，全局环境的外部引用为null，环境记录器是对象环境记录器，用来定义出现在全局上下文中的**变量和函数**的关系。

**函数词法环境**

函数内部用户定义的变量，存储在声明式环境记录器，**存储变量/函数/参数**。声明式环境记录器，包含了arguments对象杰恩传递给函数的参数的length。

对象

#### 创建变量环境

变量环境同样是一个词法环境，其环境记录器持有**变量声明语句**在执行上下文中创建的绑定关系。

在 ES6 中，**词法环境**组件和**变量环境**的一个不同就是前者被用来存储函数声明和变量（`let` 和 `const`）绑定，而后者只用来存储 `var` 变量绑定。

## 

广义的闭包——JS精粹

函数是可以实例化的，既可以被静态的声明，实例化，也可以被动态的创建。脚本和模块

函数在语法上的声明，与执行期的实例，以及实例的多次执行，都是一对多的关系。

JS中用闭包来代指一个函数实例在运行期的作用域。也就是说，闭包是记录函数实例在运行期间的“可访问标识符”的结构。

对于函数声明来说叫做实例化，对应函数表达式来说叫做 创建函数的实例。

闭包内的初始信息就是函数代码体中的那些声明，更复杂的信息还包括“运行中的函数实例”的引用、坏境，以及由包含upvalue在内的作用域链等。

在运行过程中，子函数闭包可以访问upvalue；同一个函数中所有的子函数，访问一份相同值的upvalue。

arguments.callee

- 函数实例可以拥有多个闭包
- 函数实例于闭包的生命周期是分别管理的
- 函数被调用时总是初始化一个闭包；而上次调用中的闭包是否销毁，取决于该闭包中是否有被（其他闭包）引用的变量/数据。

函数开始执行时， javas会创建一个执行环境（上下文），并将其可用标识符列表指向函数实例中的作用域，从而完成作用域到闭包的概念上的映射。闭包在根本上是运行环境中对作用域的一个引用。 