import projectConfig from '/pagic.config.js';
export default {
    'prev': {
        "text": "网络硬件",
        "link": "HTTP/internet-hardware.html"
    },
    'next': {
        "text": "基础",
        "link": "js/Object.html"
    },
    config: { "root": "/", ...projectConfig, branch: 'master' },
    'pagePath': "js/basics.md",
    'layoutPath': "_layout.tsx",
    'outputPath': "js/basics.html",
    'title': "JavaScript基础",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1>JavaScript基础</h1>\n<p>程序 = 算法 + 数据结构</p>\n<p>// 记录到wt第5章</p>\n<h2 id="javascript%E7%9A%84%E7%BB%84%E6%88%90">JavaScript的组成<a class="anchor" href="#javascript%E7%9A%84%E7%BB%84%E6%88%90">§</a></h2>\n<ul>\n<li>\n<p>词法</p>\n<ul>\n<li>直接量，关键字，运算符，标识符，保留字，操作符</li>\n</ul>\n</li>\n<li>\n<p>语法语义</p>\n<ul>\n<li>表达式，语句，函数，对象，模块</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型<a class="anchor" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h2>\n<h3 id="%E5%9F%BA%E6%9C%AC%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><strong>基本(简单)数据类型</strong><a class="anchor" href="#%E5%9F%BA%E6%9C%AC%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h3>\n<ul>\n<li>\n<p><strong>null</strong></p>\n<ul>\n<li>null是基本类型中唯一一个假值，<strong>判断null</strong> <code>!n &amp;&amp; typeof n === &quot;object&quot;</code>，null  是  JavaScript  关键字</li>\n</ul>\n</li>\n<li>\n<p><strong>undefined</strong></p>\n<ul>\n<li>Undefined  类型表示未定义，它的类型只有一个值，就是  undefined</li>\n<li><code>typeof undefined === &quot;undefined&quot;</code>，undefined是一个变量 ，undefined不是关键字，可以作为标识符，**测试chrome80下为， 全局、局部对 undefined 直接赋值已无效，全局 var undefined 无效，局部  <code>var undefined = 1</code>**有效</li>\n<li>已声明还未赋值的变量，是undefined的；没有声明的变量（有的语言中称为undeclared），是<code>ReferenceError: b is not defined</code>，但是typeof仍为undefined；使用typeof检查变量是否被声明，防止直接if()判断报错，也可以使用全局对象<code>if(window.atob)</code>。</li>\n<li>void  运算来把任一一个表达式变成  undefined</li>\n</ul>\n</li>\n<li>\n<p><strong>boolean</strong></p>\n</li>\n<li>\n<p><strong>number</strong></p>\n<ul>\n<li>\n<p><strong>指数</strong>  toExponential() 5e+10 ; toFixed()指定小数部分显示位数，52.toFiex()会报Syntax错误，.运算符会优先识别为数字常量的一部分；toPrecision() 方法指定有效数位的显示位数</p>\n<pre class="language-autoit"><code class="language-autoit">var a <span class="token operator">=</span> <span class="token number">52.55</span><span class="token comment">; a.toPrecision(1) // 5e+1 a.roPrecision(2); // 52 不足补0</span>\n</code></pre>\n</li>\n<li>\n<p><strong>整数</strong> 最大安全整数 <strong>2^53 -1</strong>，ES6中为Number.MAX_SAFE_INTEGER，最小为最大的负值 -2^53 +1，ES6中定义为Number.MAX_SAFE_INTEGER；ES6整数检测，isInteger，isSafeInteger，polyfill用Mach.abs()和MAX_SAFE_INTEGER比大小</p>\n</li>\n<li>\n<p><strong>浮点数</strong> 机器精度 二进制存储位权引起的，<strong>浮点数不等差值 Math.pow(2, -52)，ES6中 Number.EPSION</strong>，最大浮点数Number.MAX_VALUE约为1.798e+308，最小浮点数Number.MIN_VALUE大约5e-324</p>\n</li>\n<li>\n<p>进制</p>\n<ul>\n<li>十进制</li>\n<li>二进制 0b01</li>\n<li>八进制 0o77</li>\n<li>十六进制  0x1F</li>\n</ul>\n</li>\n<li>\n<p>JavaScript中的Number类型有  18437736874454810627(即2^64-2^53+3)  个值。</p>\n</li>\n<li>\n<p>0 === -0 ，ES5区分  +0  和  -0  的方式，正是 检测  1/x  是  Infinity  还是  -Infinity</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>NaN</strong>   设计NaN的操作，都会返回NaN;NaN与任何值都不相等;isNaN 会尝试把类型转换为数字类型。</p>\n<pre class="language-autoit"><code class="language-autoit"> typeof NaN<span class="token comment">; // number NaN != NaN;  isNaN();// true  isNaN(\'\'); // false </span>\n <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">; // false isNaN(true); // false </span>\n</code></pre>\n<p>全局isNaN会把字符串转化为true，ES6中的新增方法Number.isNaN()</p>\n<pre class="language-autoit"><code class="language-autoit">Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> flase    Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> <span class="token boolean">false</span>\n</code></pre>\n</li>\n<li>\n<p><strong>string</strong></p>\n<ul>\n<li>\n<p>属性方法：length indexof() concat()  toUpperCase()</p>\n</li>\n<li>\n<p>借用数组的方法</p>\n<pre class="language-autoit"><code class="language-autoit">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">\'-\'</span><span class="token punctuation">)</span>\nArray<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>\nArray<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>  <span class="token operator">/</span><span class="token operator">/</span> 笨办法，split revserse join，仅适用于不带unicode、特殊字符\n</code></pre>\n</li>\n<li>\n<p>String  有最大长度是  2^53  -  1，charAt、charCodeAt、 length  等方法针对的都是  UTF16  编码。  Unicode  的码点通常用  U+???  来表示，其 中  ???  是十六进制的码点值，0-65536（U+0000  -  U+FFFF）的码点被称为基本字符区域 。星形符号，一个字素，两个length；</p>\n</li>\n<li>\n<p>JavaScript  字符串把每个  UTF16  单元当作一个字符来处理，所以处理非BMP（超出  U+0000  -  U+FFFF  范围） 的字符时，你应该格外小心</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Object</strong></p>\n<ul>\n<li>\n<p>对象的定义是“属性的集合”，属性并非只是简单的名称和值，JavaScript用一组特征（attribute）来描述属性 （property）。属性分为数据属性和访问器属性，二者都是key-value结 构，key可以是字符串或者Symbol类型。</p>\n</li>\n<li>\n<p>函数对象的length是其声明的参数的个数</p>\n</li>\n<li></li>\n<li>\n<p>.  运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得 我们能在基础类型上调用对应对象的方法。</p>\n<ul>\n<li>\n<p>数据属性</p>\n<ul>\n<li>value：就是属性的值。</li>\n<li>writable：决定属性能否被赋值。</li>\n<li>enumerable：决定for in能否枚举该属性。</li>\n<li>configurable：决定该属性能否被删除或者改变特征值。</li>\n</ul>\n</li>\n<li>\n<p>访问器属性 访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值。</p>\n<ul>\n<li>getter：函数或undefined，在取属性值时被调用。</li>\n<li>setter：函数或undefined，在设置属性值时被调用。</li>\n<li>enumerable：决定for in能否枚举该属性。</li>\n<li>configurable：决定该属性能否被删除或者改变特征值</li>\n</ul>\n</li>\n<li>\n<p>获取方式</p>\n<ul>\n<li>Object.getOwnPropertyDescriptors(obj)</li>\n<li>Object.getOwnPropertyDescripter(O,key)</li>\n</ul>\n</li>\n<li>\n<p>Object.getOwnPropertyNames(obj)   Object.getOwnPropertySymbols(obj)  hasOwnProperty()</p>\n</li>\n<li>\n<p>Object.defineProperty 修改访问器属性</p>\n<pre class="language-autoit"><code class="language-autoit">var obj <span class="token operator">=</span> {a<span class="token punctuation">:</span><span class="token string">\'q\'</span><span class="token punctuation">,</span> get <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {return <span class="token string">\'p\'</span>}<span class="token punctuation">,</span> b<span class="token punctuation">:</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>{}} <span class="token comment">;</span>\nObject<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">\'a\'</span><span class="token punctuation">)</span>\n<span class="token operator">/</span><span class="token operator">/</span> {set<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span> enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> get<span class="token punctuation">:</span> ƒ}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>symbol</strong> 符号</p>\n<ul>\n<li>一切非字符串的对象key的集合，创建  Symbol  的方式是使用全局的  Symbol  函数，  var  mySymbol  =  Symbol(&quot;my  symbol&quot;)。</li>\n<li>Symbol  可以具有字符串类型的描述，但是即使描述相同，Symbol也不相等。</li>\n<li>Symbol.iterator  来自定义  for…of  在对象上的行为。</li>\n<li>typeof Object(Symbol(&quot;a&quot;))[Symbol.toPrimitive] ()  // \'symbol\'</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%A4%E6%96%AD">类型获取和判断<a class="anchor" href="#%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%A4%E6%96%AD">§</a></h2>\n<h3 id="%E8%8E%B7%E5%8F%96%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">获取判断数据类型<a class="anchor" href="#%E8%8E%B7%E5%8F%96%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h3>\n<ul>\n<li>\n<pre><code>运算符:typeof ，适用于基本数据类型\n-         typeof null    ---&gt; object(正确)\n\n-         typeof （function(){}）  function\n</code></pre>\n</li>\n<li>\n<p>value instanceof type  只适用于复杂数据类型</p>\n<ul>\n<li>判断一个实例是否是某一个类型，只要在当前实例的原型链上，用instanceof检测出来的结果都是true，所以在类的原型继承中，最后检测 出来的结果未必是正确的，而且instanceof后面必须更一个对象。\n不能检测基本类型</li>\n</ul>\n</li>\n<li>\n<p>constructor</p>\n<ul>\n<li>每个构造函数的原型对象都有一个constructor属性，并且指向构造函数本身，由于我们可以手动修改 这个属性，所以结果也不是很准确。 不能检测null和undefined</li>\n</ul>\n</li>\n<li>\n<p>Object.prototype.toString.call（最佳方案）</p>\n<ul>\n<li>调用Object原型上的toString()方法，并且通过call改变this指向。返回的是字符串</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E8%A1%A5%E5%85%85">补充<a class="anchor" href="#%E8%A1%A5%E5%85%85">§</a></h3>\n<ul>\n<li>\n<p>null和undefined区别</p>\n<ul>\n<li>\n<p>null表示&quot;没有对象&quot;，即该处不应该有值。</p>\n<ul>\n<li>\n<p>表达是一个对象, 但是没有存放任何引用</p>\n</li>\n<li>\n<p>可以手动赋值</p>\n<ul>\n<li>一般在准备将一个变量赋值为一个对象之前, 先赋值为null</li>\n<li>或者想要释放一个对象的时候</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>undefined表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。</p>\n<ul>\n<li>不需要手动的赋值此值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>可以使用typeof 判断一个变量是否 未定义或者未声明</p>\n<ul>\n<li>\n<p>typeof name</p>\n<ul>\n<li>undefined</li>\n</ul>\n</li>\n<li>\n<p>if (name) {  }</p>\n<ul>\n<li>这种判断是否可行?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E5%92%8C%E5%92%8C%E8%AF%B4%E6%98%8E">=和==和===说明<a class="anchor" href="#%E5%92%8C%E5%92%8C%E8%AF%B4%E6%98%8E">§</a></h2>\n<h3 id="">=<a class="anchor" href="#">§</a></h3>\n<ul>\n<li>\n<p>赋值操作</p>\n</li>\n<li>\n<p>表达式的返回值就是赋值的数值</p>\n</li>\n<li>\n<p>对条件表达式写法的影响</p>\n<ul>\n<li>if (值 == 变量) { }</li>\n</ul>\n</li>\n</ul>\n<h3 id="-1">==<a class="anchor" href="#-1">§</a></h3>\n<ul>\n<li>\n<p>基本数据类型之间</p>\n<ul>\n<li>判断两个变量 值 是否相等</li>\n</ul>\n</li>\n<li>\n<p>对象之间</p>\n<ul>\n<li>判断内存地址是否相等</li>\n</ul>\n</li>\n<li>\n<p>基本类型和对象之间</p>\n<ul>\n<li>则会将对象转换为基本数据类型数值进行比对</li>\n</ul>\n</li>\n</ul>\n<h3 id="-2">===<a class="anchor" href="#-2">§</a></h3>\n<ul>\n<li>\n<p>基本数据类型之间</p>\n<ul>\n<li>\n<p>判断两个变量 值 是否相等</p>\n<ul>\n<li>且比对类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>对象之间</p>\n<ul>\n<li>判断内存地址是否相等</li>\n</ul>\n</li>\n<li>\n<p>基本类型和对象之间</p>\n<ul>\n<li>\n<p>则会将对象转换为基本数据类型数值进行比对</p>\n<ul>\n<li>且比对类型</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换<a class="anchor" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">§</a></h2>\n<h4 id="stringtonumber">StringToNumber<a class="anchor" href="#stringtonumber">§</a></h4>\n<ul>\n<li>在不传入第二个参数的情况下，parseInt只支持16进制前缀“0x”，而且会忽略非数字字符，也不支持科学 计数法。parseFloat则直接把原字符串作为十进制来解析，Number  是比  parseInt  和  parseFloat  更好的选择。</li>\n</ul>\n<h4 id="%E8%A3%85%E7%AE%B1%E8%BD%AC%E6%8D%A2">装箱转换<a class="anchor" href="#%E8%A3%85%E7%AE%B1%E8%BD%AC%E6%8D%A2">§</a></h4>\n<p>每一类装箱对象皆有私有的  Class  属性，这些属性可以用  Object.prototype.toString  获取：</p>\n<pre class="language-autoit"><code class="language-autoit">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span>\n</code></pre>\n<p>avaScript  中，没有任何方法可以更改私有的  Class  属性，因此Object.prototype.toString  是可以准确识 别对象对应的基本类型的方法，它比  instanceof  更加准确，call本身会产生装箱操作，所以需要配合  typeof  来区分基本类型还是对象类型</p>\n<h4 id="%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2">拆箱转换<a class="anchor" href="#%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2">§</a></h4>\n<ul>\n<li>\n<p>对象到  String  和  Number  的转换都遵循“先拆箱再转换”的规则，拆箱转换会尝试调用  valueOf  和  toString  来获得拆箱后的基本类型。到  String  的拆箱转换会优先调用  toString</p>\n<pre class="language-autoit"><code class="language-autoit">var o <span class="token operator">=</span> {\n            valueOf<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> {\n              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"valueOf"</span><span class="token punctuation">)</span>\n              return {}\n            }<span class="token punctuation">,</span>\n            toString<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> {\n              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"toString"</span><span class="token punctuation">)</span>\n              return {}\n            }<span class="token punctuation">,</span>\n          }\n          o <span class="token operator">*</span> <span class="token number">2</span> \n          <span class="token operator">/</span><span class="token operator">/</span>  valueOf        <span class="token operator">/</span><span class="token operator">/</span>  toString        <span class="token operator">/</span><span class="token operator">/</span>  TypeError\n          <span class="token function">String</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>        \n          <span class="token operator">/</span><span class="token operator">/</span>  toString        <span class="token operator">/</span><span class="token operator">/</span>  valueOf        <span class="token operator">/</span><span class="token operator">/</span>  TypeError\n</code></pre>\n</li>\n<li>\n<p>拆箱转换会尝试调用  valueOf  和  toString  来获得拆箱后的基本类型，</p>\n<pre class="language-autoit"><code class="language-autoit">var o <span class="token operator">=</span> {} <span class="token comment">; </span>\no<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span>  <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">=</span><span class="token operator">></span>  {console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"toPrimitive"</span><span class="token punctuation">)</span><span class="token comment">;  return  "hello"};  </span>\no <span class="token operator">==</span> <span class="token string">\'hello\'</span>  <span class="token operator">/</span><span class="token operator">/</span> <span class="token boolean">true</span>\no <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">\'hello\'</span> <span class="token operator">/</span><span class="token operator">/</span> <span class="token boolean">false</span>\n</code></pre>\n</li>\n</ul>\n<h3 id="%E5%A4%8D%E6%9D%82%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">复杂(复合)数据类型<a class="anchor" href="#%E5%A4%8D%E6%9D%82%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h3>\n<ul>\n<li>\n<p>Object 对象类型</p>\n</li>\n<li>\n<p>Array  数组类型    ==&gt;object</p>\n</li>\n<li>\n<p>Date   日期类型    ==&gt;object</p>\n</li>\n<li>\n<p>Math   类型        ==&gt;object</p>\n</li>\n<li>\n<p>Function 函数      ==&gt;function(并非是object)</p>\n</li>\n<li>\n<p>RegExp   正则表达式</p>\n</li>\n<li>\n<p>String  字符串对象类型</p>\n</li>\n<li>\n<p>Number</p>\n</li>\n<li>\n<p>Boolean</p>\n</li>\n</ul>\n<p>Number、String和Boolean，三个构造器是两用的，当跟  new  搭配时，它们产生对象，当直接调用时，它 们表示强制类型转换。Symbol  函数比较特殊，直接用  new  调用它会抛出错误，但它仍然是  Symbol  对象的构造器。</p>\n<h3 id="%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB">基本类型和复杂类型区别<a class="anchor" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB">§</a></h3>\n<ul>\n<li>\n<p>存储方式不同</p>\n<ul>\n<li>\n<p>堆区和栈区</p>\n<ul>\n<li>\n<p>栈区特点</p>\n<ul>\n<li>\n<p>操作性能高, 速度快</p>\n</li>\n<li>\n<p>存储量小</p>\n</li>\n<li>\n<p>所以:</p>\n<ul>\n<li>一般存储操作频率较高, 生命周期较短, 占用空间较小的数据</li>\n<li>基本数据类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>堆区特点</p>\n<ul>\n<li>\n<p>操作性能低, 速度慢</p>\n</li>\n<li>\n<p>存储量大</p>\n</li>\n<li>\n<p>所以</p>\n<ul>\n<li>\n<p>一般存储  操作频率较低, 生命周期比较长, 占用空间比较大的数据</p>\n</li>\n<li>\n<p>复杂数据类型</p>\n<ul>\n<li>对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>图解</p>\n</li>\n</ul>\n</li>\n<li>\n<p>操作方式的不同</p>\n<ul>\n<li>\n<p>划分</p>\n<ul>\n<li>\n<p>值类型  string  number boolean undefined null(*)</p>\n</li>\n<li>\n<p>引用类型</p>\n<ul>\n<li>\n<pre><code>Object类型,以下类型其本质都是object类型，Function ，Array， Date， String，Number，Boolean\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>值&amp;引用</p>\n<ul>\n<li>\n<p>赋值</p>\n<ul>\n<li>值类型赋值</li>\n<li>引用类型赋值</li>\n</ul>\n</li>\n<li>\n<p>传递</p>\n<ul>\n<li>函数中的参数传递</li>\n</ul>\n</li>\n<li>\n<p>技巧</p>\n<ul>\n<li>脑中有图</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id="%E6%95%B0%E7%BB%84">数组<a class="anchor" href="#%E6%95%B0%E7%BB%84">§</a></h4>\n<p>字符串键值如果能强制转换为十进制数字，则会被当作数字索引。</p>\n<pre class="language-autoit"><code class="language-autoit">var a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment">; a[\'8\'] = 99; a.length // 9</span>\n</code></pre>\n<h5 id="%E7%B1%BB%E6%95%B0%E7%BB%84">类数组<a class="anchor" href="#%E7%B1%BB%E6%95%B0%E7%BB%84">§</a></h5>\n<p>DOM元素列表，arguments对象，转数组</p>\n<ul>\n<li>\n<p>Array.prototype.slice.call(arguments)</p>\n</li>\n<li>\n<p>ES6中的 Array.from(args)</p>\n</li>\n<li>\n<p>核心</p>\n</li>\n<li>\n<p>注意:</p>\n<ul>\n<li>\n<p>定义的仅仅是语言基础</p>\n<ul>\n<li>语法</li>\n<li>类型</li>\n<li>语句</li>\n<li>关键字</li>\n<li>保留字</li>\n<li>操作符</li>\n<li>对象</li>\n<li>...</li>\n</ul>\n</li>\n<li>\n<p>宿主环境提供了该语言的基本实现和扩展</p>\n<ul>\n<li>比如DOM</li>\n</ul>\n</li>\n<li>\n<p>与Web浏览器没有依赖关系</p>\n<ul>\n<li>浏览器只是ECMAScript实现的宿主环境之一</li>\n</ul>\n</li>\n<li>\n<p>其他宿主环境</p>\n<ul>\n<li>\n<p>Node</p>\n<ul>\n<li>服务器端的JavaScript平台</li>\n</ul>\n</li>\n<li>\n<p>Adobe Flash</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="dom">DOM<a class="anchor" href="#dom">§</a></h3>\n<ul>\n<li>\n<p>文档对象模型</p>\n</li>\n<li>\n<p>功能</p>\n<ul>\n<li>\n<ol>\n<li>把整个页面映射成为一个多层节点结构</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>然后提供了一套对这些节点(内容)增删改查的方法</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>DOM级别</p>\n<ul>\n<li>\n<p>DOM1</p>\n<ul>\n<li>\n<p>DOM Core</p>\n<ul>\n<li>如何映射基于XML的文档结构</li>\n</ul>\n</li>\n<li>\n<p>DOM HTML</p>\n<ul>\n<li>添加了针对HTML的对象和方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>DOM2</p>\n<ul>\n<li>\n<p>扩充了鼠标和用户界面事件, 范围,遍历等细分模块</p>\n</li>\n<li>\n<p>通过对象接口增加了对CSS的支持</p>\n</li>\n<li>\n<p>具体</p>\n<ul>\n<li>\n<p>DOM视图</p>\n<ul>\n<li>定义了跟踪不同文档视图的接口</li>\n</ul>\n</li>\n<li>\n<p>DOM事件</p>\n<ul>\n<li>定义了事件和事件处理的接口</li>\n</ul>\n</li>\n<li>\n<p>DOM样式</p>\n<ul>\n<li>定义了基于CSS, 操作元素样式的接口</li>\n</ul>\n</li>\n<li>\n<p>DOM遍历和范围</p>\n<ul>\n<li>定义了遍历和操作文档树的接口</li>\n<li>新增了验证文档的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>DOM3</p>\n<ul>\n<li>引入了以统一方式加载和保存文档的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>注意</p>\n<ul>\n<li>针对于XML但经过扩展,用于HTML的应用程序编程接口(API)</li>\n<li>不只是针对于JavaScript的, 很多其他语言也实现了DOM</li>\n</ul>\n</li>\n</ul>\n<h3 id="bom">BOM<a class="anchor" href="#bom">§</a></h3>\n<ul>\n<li>\n<p>浏览器对象模型</p>\n</li>\n<li>\n<p>作用</p>\n<ul>\n<li>处理浏览器窗口和框架</li>\n<li>习惯于把针对于浏览器操作的JS扩展也归为BOM</li>\n</ul>\n</li>\n<li>\n<p>具体功能</p>\n<ul>\n<li>弹出新浏览器窗口的功能</li>\n<li>移动,缩放和关闭浏览器窗口的功能</li>\n<li>提供浏览器详细信息的navigator对象</li>\n<li>提供浏览器所加载页面的详细信息的location对象</li>\n<li>提供用户显示器分辨率详细信息的screen对象</li>\n<li>对cookie的支持</li>\n<li>XMLHttpRequest -- ActiveXObject</li>\n</ul>\n</li>\n</ul>\n<h3 id="-3"><a class="anchor" href="#-3">§</a></h3>\n<hr>\n<hr>\n<h2 id="05-ecmascript-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">05-ECMAScript-关系运算符<a class="anchor" href="#05-ecmascript-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">§</a></h2>\n<h3 id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E6%9E%9C%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">关系运算符(结果是布尔类型)<a class="anchor" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E6%9E%9C%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">§</a></h3>\n<h3 id="%E5%A4%A7%E4%BA%8E">大于(&gt;)<a class="anchor" href="#%E5%A4%A7%E4%BA%8E">§</a></h3>\n<h3 id="%E5%B0%8F%E4%BA%8E">小于(&lt;)<a class="anchor" href="#%E5%B0%8F%E4%BA%8E">§</a></h3>\n<h3 id="%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%B0%8F%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E">小于等于(&lt;=) 小于或者是等于<a class="anchor" href="#%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%B0%8F%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E">§</a></h3>\n<h3 id="%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%A4%A7%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E">大于等于(&gt;=) 大于或者是等于<a class="anchor" href="#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%A4%A7%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E">§</a></h3>\n<h3 id="%E4%B8%8D%E7%AD%89%E4%BA%8E">不等于(!=)<a class="anchor" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E">§</a></h3>\n<h3 id="%E6%B3%A8%E6%84%8F">注意:<a class="anchor" href="#%E6%B3%A8%E6%84%8F">§</a></h3>\n<ul>\n<li>\n<p>基本数据类型之间</p>\n<ul>\n<li>转换成同类型进行值比对</li>\n</ul>\n</li>\n<li>\n<p>对象类型之间</p>\n<ul>\n<li>\n<p>比如数组</p>\n</li>\n<li>\n<blockquote>\n<p>&lt; &gt;= &lt;=</p>\n</blockquote>\n<ul>\n<li>会转换成值进行比对</li>\n</ul>\n</li>\n<li>\n<p>!=</p>\n<ul>\n<li>\n<p>与==相反</p>\n<ul>\n<li>比对的是内存地址</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>基本数据类型和对象类型之间</p>\n<ul>\n<li>则会将对象转换为基本数据类型数值进行比对</li>\n</ul>\n</li>\n</ul>\n<h2 id="06-ecmascript-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">06-ECMAScript-逻辑运算符<a class="anchor" href="#06-ecmascript-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">§</a></h2>\n<h3 id="01-%E9%80%BB%E8%BE%91%E9%9D%9E">01 逻辑非<a class="anchor" href="#01-%E9%80%BB%E8%BE%91%E9%9D%9E">§</a></h3>\n<ul>\n<li>\n<pre><code>符号:!\n</code></pre>\n</li>\n<li>\n<pre><code>操作符: !表达式\n</code></pre>\n</li>\n<li>\n<pre><code>结果:布尔类型的值,要么是true要么是false\n</code></pre>\n</li>\n<li>\n<p>0 \'\' false null undefined</p>\n<ul>\n<li>取反全为true</li>\n</ul>\n</li>\n</ul>\n<h3 id="02-%E9%80%BB%E8%BE%91%E4%B8%8E">02 逻辑与<a class="anchor" href="#02-%E9%80%BB%E8%BE%91%E4%B8%8E">§</a></h3>\n<ul>\n<li>\n<pre><code>符号:&amp;&amp;\n</code></pre>\n</li>\n<li>\n<pre><code>操作符:表达式1 &amp;&amp; 表达式2\n</code></pre>\n</li>\n</ul>\n<h3 id="03-%E9%80%BB%E8%BE%91%E6%88%96">03 逻辑或<a class="anchor" href="#03-%E9%80%BB%E8%BE%91%E6%88%96">§</a></h3>\n<ul>\n<li>\n<pre><code>符号:||\n</code></pre>\n</li>\n<li>\n<pre><code>操作符:表达式1 || 表达式2\n</code></pre>\n</li>\n</ul>\n<h3 id="%E6%B3%A8%E6%84%8F-1">注意:<a class="anchor" href="#%E6%B3%A8%E6%84%8F-1">§</a></h3>\n<ul>\n<li>\n<ol>\n<li>注意逻辑与和逻辑或的返回值, 并非boolean类型</li>\n</ol>\n<ul>\n<li>\n<p>逻辑与</p>\n<ul>\n<li>\n<pre><code>一假全假\n</code></pre>\n<ul>\n<li>\n<pre><code> 如果表达式1为假,那么就返回表达式1,否则就返回表达式2\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>逻辑或</p>\n<ul>\n<li>\n<pre><code>一真全真\n</code></pre>\n<ul>\n<li>\n<pre><code>    如果表达式1为真,那么就返回表达式1,否则就返回表达式2\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ol start="2">\n<li>逻辑与和逻辑或也被称为短路运算符</li>\n</ol>\n<ul>\n<li>\n<p>逻辑与</p>\n<ul>\n<li>\n<p>一假全假</p>\n<ul>\n<li>第一个假的,后面不会再进行执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>逻辑或</p>\n<ul>\n<li>\n<p>一真全真</p>\n<ul>\n<li>第一个真的, 后面不会再执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="07-ecmascript-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF">07-ECMAScript-分支和循环<a class="anchor" href="#07-ecmascript-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF">§</a></h2>\n<h3 id="%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">条件结构<a class="anchor" href="#%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">§</a></h3>\n<ul>\n<li>\n<p>if..else</p>\n</li>\n<li>\n<p>?:</p>\n</li>\n<li>\n<p>switch..case</p>\n</li>\n<li>\n<p>案例</p>\n<ul>\n<li>分数级别</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">循环结构<a class="anchor" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">§</a></h3>\n<ul>\n<li>\n<p>for循环</p>\n</li>\n<li>\n<p>for...in(主要用于遍历对象)</p>\n</li>\n<li>\n<p>while</p>\n</li>\n<li>\n<p>do...while(至少会执行一次)</p>\n</li>\n<li>\n<p>案例</p>\n<ul>\n<li>99乘法表</li>\n<li>阶乘</li>\n</ul>\n</li>\n<li>\n<p>注意:</p>\n<ul>\n<li>break</li>\n<li>continue</li>\n<li>label</li>\n</ul>\n</li>\n</ul>\n<h2 id="08-ecmascript-%E5%87%BD%E6%95%B0">08-ECMAScript-函数<a class="anchor" href="#08-ecmascript-%E5%87%BD%E6%95%B0">§</a></h2>\n<h3 id="1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA">1. 函数的几种创建?<a class="anchor" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA">§</a></h3>\n<ul>\n<li>\n<pre><code>01 声明函数\n</code></pre>\n<ul>\n<li>\n<pre><code>function 函数名称 (形参1,形参2)\n</code></pre>\n</li>\n<li>\n<pre><code>{\n</code></pre>\n</li>\n<li>\n<pre><code>    //函数体\n</code></pre>\n</li>\n<li>\n<pre><code>}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<pre><code>02 函数表达式\n</code></pre>\n<ul>\n<li>\n<p>01 匿名函数</p>\n<ul>\n<li>\n<pre><code>var func01 = function (){\n</code></pre>\n</li>\n<li>\n<pre><code>};\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>02 命名的函数表达式</p>\n<ul>\n<li>var func02 = function func(){</li>\n<li>\n<pre><code>};\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<pre><code>03 使用构造函数创建函数对象\n</code></pre>\n<ul>\n<li>\n<pre><code>var func02 = new Function(&quot;console.log(\'demo\');&quot;);\n</code></pre>\n</li>\n<li>\n<pre><code>func02();\n</code></pre>\n</li>\n<li>\n<p>可以传递N个参数</p>\n<ul>\n<li>会把最后一个参数, 当做函数体;</li>\n<li>其他参数当做函数形参</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="2-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7">2. 函数使用技巧<a class="anchor" href="#2-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7">§</a></h3>\n<ul>\n<li>\n<p>形参和arguments</p>\n<ul>\n<li>该参数是一个类似于数组的结构（可以像数组一样遍历 + 还可以使用下标来访问数据），但是并不是数组。</li>\n<li>\n<pre><code>          01 函数调用的时候，会把实参的值赋值给形参，而且会使用arguments来接收实参\n</code></pre>\n</li>\n<li>\n<pre><code>          02 如果实参的个数超过形参的个数，那么可以通过arguments来获取超出的数据\n</code></pre>\n</li>\n<li>\n<pre><code>          03 如果实参的格式小于形参的个数，那么不足的全部设置为undefined\n</code></pre>\n</li>\n<li>两者之间是关联的关系</li>\n</ul>\n</li>\n<li>\n<p>length属性</p>\n<ul>\n<li>\n<p>函数名.length</p>\n<ul>\n<li>形参的长度（个数）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>name属性</p>\n<ul>\n<li>函数名称</li>\n</ul>\n</li>\n<li>\n<p>函数重载</p>\n<ul>\n<li>\n<p>概念</p>\n<ul>\n<li>函数名相同, 但是根据传递的参数不同可以实现不同的功能</li>\n</ul>\n</li>\n<li>\n<p>例如</p>\n<ul>\n<li>function sum(a, b)</li>\n<li>function sum(a, b, c)</li>\n<li>可以同时存在</li>\n</ul>\n</li>\n<li>\n<p>但是:js没有函数重载!</p>\n<ul>\n<li>但是可以通过arguments个数来模拟重载</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>js模板使用</p>\n</li>\n</ul>\n<h3 id="3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%AB%E6%B3%95">3. 函数的几种叫法?<a class="anchor" href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%AB%E6%B3%95">§</a></h3>\n<ul>\n<li>\n<p>函数</p>\n<ul>\n<li>命名函数</li>\n<li>匿名函数</li>\n</ul>\n</li>\n<li>\n<p>闭包</p>\n<ul>\n<li>\n<p>可以在其他函数作用域之外访问其他函数内部变量的函数</p>\n<ul>\n<li>由函数内部返回给外界的函数</li>\n<li>由外界传递到函数内部的函数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>方法</p>\n<ul>\n<li>\n<p>有宿主</p>\n<ul>\n<li>静态方法</li>\n<li>实例方法</li>\n</ul>\n</li>\n<li>\n<p>需要通过宿主来调用</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="09-ecmascript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98">09-ECMAScript-作用域问题<a class="anchor" href="#09-ecmascript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98">§</a></h2>\n<h3 id="%E6%A6%82%E5%BF%B5%E6%9F%90%E4%B8%AA%E5%8F%98%E9%87%8F%E6%9C%89%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%8C%83%E5%9B%B4">概念：某个变量有（起）作用的范围<a class="anchor" href="#%E6%A6%82%E5%BF%B5%E6%9F%90%E4%B8%AA%E5%8F%98%E9%87%8F%E6%9C%89%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%8C%83%E5%9B%B4">§</a></h3>\n<h3 id="js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">js中的作用域<a class="anchor" href="#js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">§</a></h3>\n<ul>\n<li>\n<p>01-script标签构成的全局作用域</p>\n</li>\n<li>\n<p>02-块级作用域</p>\n<ul>\n<li>在其他语言中, 由{}包含的代码块都有自己的作用域</li>\n<li>在其他语言中，有块级作用域，但是在js中没有块级作用域</li>\n</ul>\n</li>\n<li>\n<p>03-在js中函数是唯一一个可以创建作用域的对象</p>\n<ul>\n<li>\n<p>注意:</p>\n<ul>\n<li>如果没有通过var关键字声明变量, 则为全局变量</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">作用域链<a class="anchor" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">§</a></h3>\n<ul>\n<li>01 js中函数可以创建作用域</li>\n<li>02 js中的函数中可以声明函数</li>\n<li>03 函数内部的函数中又可以声明函数</li>\n<li>04 以上,会形成一个链式的结构,这个是作用域链</li>\n</ul>\n<h3 id="%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99">变量查找原则<a class="anchor" href="#%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99">§</a></h3>\n<ul>\n<li>就近原则</li>\n<li>从内到外</li>\n</ul>\n<h2 id="10-ecmascript-%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87">10-ECMAScript-变量和函数提升<a class="anchor" href="#10-ecmascript-%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87">§</a></h2>\n<h3 id="js%E7%9A%84%E6%89%A7%E8%A1%8C">js的执行：<a class="anchor" href="#js%E7%9A%84%E6%89%A7%E8%A1%8C">§</a></h3>\n<ul>\n<li>\n<pre><code>01 预解析阶段  变量和函数的提升（声明）\n</code></pre>\n</li>\n<li>\n<pre><code>02 具体的执行阶段\n</code></pre>\n</li>\n</ul>\n<h3 id="%E8%A7%84%E5%88%99">规则<a class="anchor" href="#%E8%A7%84%E5%88%99">§</a></h3>\n<ul>\n<li>\n<p>0-会把变量的声明提升到当前作用域的最前面</p>\n<ul>\n<li>赋值放在原位置不动</li>\n</ul>\n</li>\n<li>\n<p>1-会把函数声明提升到当前作用域前面</p>\n<ul>\n<li>\n<p>紧接着被提升过的其他声明</p>\n</li>\n<li>\n<p>注意:</p>\n<ul>\n<li>\n<p>函数的声明包含了函数体</p>\n</li>\n<li>\n<p>如果是函数的表达式</p>\n<ul>\n<li>只会把var 变量的名称(函数)提升到当前作用域的最顶端</li>\n</ul>\n</li>\n<li>\n<p>特例写法</p>\n<ul>\n<li>\n<p>if (condition) {\nfunction a() {alert(\'1\')};\n}else {\nfunction a() {alert(\'2\')};\n}</p>\n<ul>\n<li>不要这样写!!!</li>\n</ul>\n</li>\n<li>\n<p>使用函数表达式的形式修正</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>2-变量和变量同名的情况:后面的变量会把前面的变量覆盖</p>\n</li>\n<li>\n<p>3-函数和函数同名的情况,后面的会把前面的覆盖</p>\n</li>\n<li>\n<p>4-函数和变量同名的情况:</p>\n<ul>\n<li>变量的声明不会覆盖函数的声明</li>\n</ul>\n</li>\n<li>\n<p>5-变量提升无法脱离所在作用域</p>\n</li>\n</ul>\n<h3 id="%E6%B5%8B%E8%AF%95">测试<a class="anchor" href="#%E6%B5%8B%E8%AF%95">§</a></h3>\n<ul>\n<li>\n<p>测试1</p>\n<pre><code>function foo() {\n    var num = 123;\n    console.log(num);\n}\n\nfoo();          \nconsole.log(num); \n</code></pre>\n</li>\n<li>\n<p>测试2</p>\n<pre><code>var scope = &quot;global&quot;;\nfoo();\nfunction foo() {\n    console.log(scope);\n    var scope = &quot;local&quot;;\n    console.log(scope);\n}\nconsole.log(scope);\n</code></pre>\n</li>\n<li>\n<p>测试3</p>\n<pre><code>function f1(){\n    if(&quot;a&quot; in window){\n        var a = 10;\n    }\n    console.log(a);\n}\nf1();\n</code></pre>\n</li>\n<li>\n<p>测试4</p>\n<pre><code>if(&quot;a&quot; in window){\n    var a = 10;\n}\nconsole.log(a);\n</code></pre>\n</li>\n<li>\n<p>测试5</p>\n<pre><code>var foo = 1;\nfunction bar() {\n    if(!foo)\n    {\n        var foo = 10;\n    }\n    alert(foo);\n}\nbar();\n</code></pre>\n</li>\n<li>\n<p>绘制作用域图</p>\n<pre><code>var a = 10;\nfunction f1(){\n    function f2(){\n        var d = &quot;demoD&quot;;\n    }\n}\n\nfunction f3(){\n    function f4(){\n    }\n    var b = &quot;demoB&quot;;\n    function f5(){\n        var c = &quot;demoC&quot;\n    }\n}\n</code></pre>\n</li>\n</ul>\n<h2 id="11-ecmascript-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">11-ECMAScript-异常处理<a class="anchor" href="#11-ecmascript-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">§</a></h2>\n<h3 id="%E5%9C%BA%E6%99%AF">场景<a class="anchor" href="#%E5%9C%BA%E6%99%AF">§</a></h3>\n<ul>\n<li>正常情况下,如果程序出现了错误或者是异常,那么该行代码后面的所有代码都无法得到执行</li>\n<li>但是,有些时候我们需要保证即便程序出现了问题,后面的代码也能够正常执行,这种情况就可以使用异常捕获结构</li>\n</ul>\n<h3 id="%E4%BD%BF%E7%94%A8">使用<a class="anchor" href="#%E4%BD%BF%E7%94%A8">§</a></h3>\n<ul>\n<li>\n<p>抛出异常</p>\n<ul>\n<li>\n<p>throw</p>\n<ul>\n<li>字符串</li>\n<li>对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>捕捉异常</p>\n<ul>\n<li>\n<pre><code>try{\n</code></pre>\n</li>\n<li>\n<pre><code>    //可能出错的代码\n</code></pre>\n</li>\n<li>\n<pre><code>}catch (e){\n</code></pre>\n</li>\n<li>\n<pre><code>    //出错了就执行这个代码块\n</code></pre>\n</li>\n<li>\n<pre><code>}\n</code></pre>\n</li>\n<li>\n<pre><code>finally\n</code></pre>\n</li>\n<li>\n<pre><code>{\n</code></pre>\n</li>\n<li>\n<pre><code>    //不管是否出错,都会执行这里的代码块\n</code></pre>\n</li>\n<li>\n<pre><code>    //一般在前端开发中不会使用,多多用于后端开发Node.js 主要用于在最后释放资源\n</code></pre>\n</li>\n<li>\n<pre><code>}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="12-dom-%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">12-DOM-操作(增删改查)<a class="anchor" href="#12-dom-%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">§</a></h2>\n<h3 id="%E5%A2%9E%E5%8A%A0">增加<a class="anchor" href="#%E5%A2%9E%E5%8A%A0">§</a></h3>\n<ul>\n<li>\n<p>创建tag</p>\n<ul>\n<li>document.createElement(&quot;div&quot;);</li>\n</ul>\n</li>\n<li>\n<p>添加tag</p>\n<ul>\n<li>appendChild</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E5%88%A0%E9%99%A4">删除<a class="anchor" href="#%E5%88%A0%E9%99%A4">§</a></h3>\n<ul>\n<li>parent.removeChild(child);</li>\n</ul>\n<h3 id="%E4%BF%AE%E6%94%B9">修改<a class="anchor" href="#%E4%BF%AE%E6%94%B9">§</a></h3>\n<ul>\n<li>\n<p>主要只修改内部属性</p>\n<ul>\n<li>innerHTML</li>\n<li>style</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E6%9F%A5%E8%AF%A2">查询<a class="anchor" href="#%E6%9F%A5%E8%AF%A2">§</a></h3>\n<ul>\n<li>根据标签查询</li>\n<li>根据ID查询</li>\n<li>根据class查询</li>\n<li>查询所有</li>\n<li>...</li>\n</ul>\n<h2 id="13-bom-%E6%93%8D%E4%BD%9C">13-BOM-操作<a class="anchor" href="#13-bom-%E6%93%8D%E4%BD%9C">§</a></h2>\n<h3 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">浏览器对象模型<a class="anchor" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">§</a></h3>\n<h3 id="%E4%BD%9C%E7%94%A8">作用<a class="anchor" href="#%E4%BD%9C%E7%94%A8">§</a></h3>\n<ul>\n<li>处理浏览器窗口和框架</li>\n<li>习惯于把针对于浏览器操作的JS扩展也归为BOM</li>\n</ul>\n<h3 id="%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD">具体功能<a class="anchor" href="#%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD">§</a></h3>\n<ul>\n<li>弹出新浏览器窗口的功能</li>\n<li>移动,缩放和关闭浏览器窗口的功能</li>\n<li>提供浏览器详细信息的navigator对象</li>\n<li>提供浏览器所加载页面的详细信息的location对象</li>\n<li>提供用户显示器分辨率详细信息的screen对象</li>\n<li>对cookie的支持</li>\n<li>XMLHttpRequest -- ActiveXObject</li>\n</ul>\n<h3 id="%E9%87%8D%E8%A6%81%E5%AF%B9%E8%B1%A1">重要对象<a class="anchor" href="#%E9%87%8D%E8%A6%81%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>\n<p>window</p>\n<ul>\n<li>\n<p>标识浏览器的一个实例</p>\n</li>\n<li>\n<p>全局作用域</p>\n<ul>\n<li>全局作用域中的变量或者函数都会变成window的属性或者方法</li>\n</ul>\n</li>\n<li>\n<p>窗口位置</p>\n<ul>\n<li>moveTo</li>\n<li>moveBy</li>\n<li>可能被禁用</li>\n</ul>\n</li>\n<li>\n<p>窗口大小</p>\n<ul>\n<li>resizeTo</li>\n<li>resizeBy</li>\n<li>可能被禁用</li>\n</ul>\n</li>\n<li>\n<p>导航和打开窗口</p>\n<ul>\n<li>\n<p>open</p>\n<ul>\n<li>\n<pre><code>参数1: 需要加载的URL\n</code></pre>\n</li>\n<li>\n<pre><code>参数2: 窗口目标\n</code></pre>\n<ul>\n<li>窗口名称</li>\n<li>_self</li>\n<li>_parent</li>\n<li>_top</li>\n<li>_blank</li>\n</ul>\n</li>\n<li>\n<pre><code>参数3: 一个特性字符串(,分割)\n</code></pre>\n<ul>\n<li>\n<p>fullScreen</p>\n<ul>\n<li>yes/no</li>\n</ul>\n</li>\n<li>\n<p>width</p>\n</li>\n<li>\n<p>height</p>\n</li>\n<li>\n<p>left</p>\n</li>\n<li>\n<p>top</p>\n</li>\n<li>\n<p>toolbar</p>\n</li>\n<li>\n<p>status</p>\n</li>\n<li>\n<p>resizable</p>\n</li>\n</ul>\n</li>\n<li>\n<pre><code>参数4: 是否取代浏览器历史集中中当前加载页面的Boolean值\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>间歇调用和超时调用</p>\n<ul>\n<li>setInterval</li>\n<li>setTimeout</li>\n</ul>\n</li>\n<li>\n<p>系统对话框</p>\n<ul>\n<li>\n<p>confirm</p>\n<ul>\n<li>确认框</li>\n</ul>\n</li>\n<li>\n<p>alert</p>\n<ul>\n<li>消息框</li>\n</ul>\n</li>\n<li>\n<p>prompt</p>\n<ul>\n<li>输入框</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>location</p>\n<ul>\n<li>\n<p>提供了与当前窗口中加载的文档有关的信息, 还提供了一些导航功能</p>\n</li>\n<li>\n<p>window.location === document.location</p>\n</li>\n<li>\n<p>常用属性</p>\n<ul>\n<li>\n<p>hash</p>\n</li>\n<li>\n<p>href</p>\n<ul>\n<li><a href="http://www.520it.com:80/person/sz.php?param1=name&amp;param2=age">http://www.520it.com:80/person/sz.php?param1=name&amp;param2=age</a></li>\n</ul>\n</li>\n<li>\n<p>protocol</p>\n<ul>\n<li>http:</li>\n</ul>\n</li>\n<li>\n<p>host</p>\n<ul>\n<li><a href="http://www.520it.com:80">www.520it.com:80</a></li>\n</ul>\n</li>\n<li>\n<p>hostname</p>\n<ul>\n<li><a href="http://www.520it.com">www.520it.com</a></li>\n</ul>\n</li>\n<li>\n<p>port</p>\n<ul>\n<li>80</li>\n</ul>\n</li>\n<li>\n<p>pathname</p>\n<ul>\n<li>/person/</li>\n</ul>\n</li>\n<li>\n<p>search</p>\n<ul>\n<li>?param1=name&amp;param2=age</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>查询字符串参数</p>\n<ul>\n<li>查询串需要我们自己解析</li>\n</ul>\n</li>\n<li>\n<p>位置操作</p>\n<ul>\n<li>\n<p>window.location.assign(url)</p>\n</li>\n<li>\n<p>window.location =url</p>\n</li>\n<li>\n<p>window.location.href =url</p>\n</li>\n<li>\n<p>注意</p>\n<ul>\n<li>\n<p>以上三句代码, 效果等同, 都会重新加载最新url</p>\n</li>\n<li>\n<p>另外, 修改了location的属性, 也会触发重新加载网页</p>\n<ul>\n<li>hash除外</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>navigator</p>\n<ul>\n<li>\n<p>识别客户端信息的事实标准</p>\n<ul>\n<li>\n<p>appCodeName</p>\n<ul>\n<li>浏览器名称</li>\n</ul>\n</li>\n<li>\n<p>appName</p>\n<ul>\n<li>完整的浏览器名称</li>\n</ul>\n</li>\n<li>\n<p>appVersion</p>\n<ul>\n<li>浏览器版本</li>\n</ul>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>screen</p>\n<ul>\n<li>\n<p>浏览器窗口的描述信息</p>\n<ul>\n<li>width/height</li>\n<li>top/left</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>history</p>\n<ul>\n<li>\n<p>上网的历史记录</p>\n</li>\n<li>\n<p>go(num)</p>\n<ul>\n<li>前进/后退几页</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">14-面向对象-相关概念<a class="anchor" href="#14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">§</a></h2>\n<h3 id="01-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1">01-什么是对象?<a class="anchor" href="#01-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>\n<p>万物皆对象</p>\n</li>\n<li>\n<pre><code>对象是具体物体\n</code></pre>\n<ul>\n<li>拥有属性</li>\n<li>拥有行为</li>\n<li>把很多零散的东西, 封装成为一个整体</li>\n</ul>\n</li>\n<li>\n<pre><code>举例: \n</code></pre>\n<ul>\n<li>\n<p>王二小</p>\n<ul>\n<li>\n<p>属性</p>\n<ul>\n<li>姓名</li>\n<li>年龄</li>\n<li>身高</li>\n<li>体重</li>\n<li>...</li>\n</ul>\n</li>\n<li>\n<p>行为</p>\n<ul>\n<li>走路</li>\n<li>吃饭</li>\n<li>放羊</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>DOM节点</p>\n<ul>\n<li>\n<p>属性</p>\n<ul>\n<li>innerHTML</li>\n<li>innerTEXT</li>\n<li>style</li>\n<li>...</li>\n</ul>\n</li>\n<li>\n<p>行为</p>\n<ul>\n<li>removeChild(child);</li>\n<li>appendChild()</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">02-面向对象-面向过程<a class="anchor" href="#02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">§</a></h3>\n<ul>\n<li>\n<pre><code>都是一种解决问题的思路(思想)\n</code></pre>\n</li>\n<li>\n<pre><code>面向过程\n</code></pre>\n<ul>\n<li>在解决问题的时候,关注的是解决问题需要的一个接着一个的过程(步骤)</li>\n</ul>\n</li>\n<li>\n<pre><code>面向对象\n</code></pre>\n<ul>\n<li>在解决问题的时候,关注的是解决问题所需要的对象.</li>\n</ul>\n</li>\n<li>\n<p>对比</p>\n<ul>\n<li>\n<p>面向对象和面向过程都是解决问题的一种方式(思想)</p>\n<ul>\n<li>面向对象本身是对面向过程的封装.</li>\n</ul>\n</li>\n<li>\n<p>面向对象编程最重要的什么?</p>\n<ul>\n<li>\n<p>找到对象, 确定对象属性和行为</p>\n</li>\n<li>\n<p>小案例</p>\n<ul>\n<li>\n<p>做好饭之后洗碗</p>\n<ul>\n<li>\n<p>面向过程</p>\n<ul>\n<li>\n<p>你</p>\n<ul>\n<li>洗菜</li>\n<li>点火倒油</li>\n<li>放菜,材料</li>\n<li>翻炒</li>\n<li>盛出</li>\n<li>放水</li>\n<li>放碗</li>\n<li>倒洗洁精</li>\n<li>开始刷</li>\n<li>擦干水</li>\n<li>摆放好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>面向对象</p>\n<ul>\n<li>\n<p>你</p>\n<ul>\n<li>\n<p>对象</p>\n<ul>\n<li>\n<p>技能1: 做饭</p>\n<ul>\n<li>洗菜</li>\n<li>点火倒油</li>\n<li>放菜,材料</li>\n<li>翻炒</li>\n<li>盛出</li>\n</ul>\n</li>\n<li>\n<p>技能2:洗碗</p>\n<ul>\n<li>放水</li>\n<li>放碗</li>\n<li>倒洗洁精</li>\n<li>开始刷</li>\n<li>擦干水</li>\n<li>摆放好</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>你</p>\n<ul>\n<li>\n<p>对象</p>\n<ul>\n<li>\n<p>技能1: 做饭</p>\n<ul>\n<li>\n<p>放菜,材料</p>\n</li>\n<li>\n<p>自动炒菜机</p>\n<ul>\n<li>搅拌</li>\n<li>翻炒</li>\n<li>监测火候</li>\n</ul>\n</li>\n<li>\n<p>盛出</p>\n</li>\n</ul>\n</li>\n<li>\n<p>技能2:洗碗</p>\n<ul>\n<li>\n<p>放水/放碗</p>\n</li>\n<li>\n<p>自动洗碗机</p>\n<ul>\n<li>倒洗洁精</li>\n<li>开始刷</li>\n<li>擦干水</li>\n</ul>\n</li>\n<li>\n<p>摆放好</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>面向对象的好处</p>\n<ul>\n<li>\n<pre><code>01 更方便\n</code></pre>\n</li>\n<li>\n<pre><code>02 复用性会更好\n</code></pre>\n</li>\n<li>\n<pre><code>03 高内聚和低耦合\n</code></pre>\n</li>\n<li>\n<pre><code>04 冗余(重复的东西)--&gt;封装(提取相同的部分作为函数体,抽取不同的部分作为参数)\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F">15-面向对象-创建对象的方式<a class="anchor" href="#15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F">§</a></h2>\n<h3 id="%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">字面量的方式创建对象<a class="anchor" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>问题:使用内置构造函数的方式和字面量的方式来创建对象差不多,都存在以下问题:</li>\n<li>\n<pre><code>  01 创建的对象无法复用,复用性差\n</code></pre>\n</li>\n<li>\n<pre><code>  02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高\n</code></pre>\n</li>\n</ul>\n<h3 id="%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">内置构造函数的方式来创建对象<a class="anchor" href="#%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>问题:使用内置构造函数的方式和字面量的方式来创建对象差不多,都存在以下问题:</li>\n<li>\n<pre><code>  01 创建的对象无法复用,复用性差\n</code></pre>\n</li>\n<li>\n<pre><code>  02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高\n</code></pre>\n</li>\n</ul>\n<h3 id="%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">简单工厂函数的方式来创建对象<a class="anchor" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>\n<p>简单工厂模式</p>\n<ul>\n<li>\n<p>工厂里面有一些产品的模板, 只需要, 给工厂提供原材料; 工厂按照固定的加工方式, 就可以返回给外界同一类型的产品</p>\n</li>\n<li>\n<p>问题:</p>\n<ul>\n<li>无法判定类型</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">自定义构造函数的方式来创建对象<a class="anchor" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>\n<p>01-自定义构造函数和简单工厂函数的对比</p>\n<ul>\n<li>\n<pre><code>① 函数的首字母大写(用于区别构造函数和普通函数)\n</code></pre>\n</li>\n<li>\n<pre><code>② 创建对象的过程是由new关键字实现\n</code></pre>\n</li>\n<li>\n<pre><code>③ 在构造函数内部会自动的创建新对象,并赋值给this指针\n</code></pre>\n</li>\n<li>\n<pre><code>④ 自动返回创建出来的对象\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>02-构造函数的执行过程:</p>\n<ul>\n<li>\n<pre><code>① 使用new关键字创建对象\n</code></pre>\n<ul>\n<li>外界</li>\n</ul>\n</li>\n<li>\n<pre><code>② 把新创建出来的对象赋值给this\n</code></pre>\n</li>\n<li>\n<pre><code>③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法\n</code></pre>\n</li>\n<li>\n<pre><code>④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>03-构造函数的返回值说明:</p>\n<ul>\n<li>\n<pre><code>01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象\n</code></pre>\n</li>\n<li>\n<pre><code>02 如果在构造函数中显示的return,则依照具体的情况处理\n</code></pre>\n<ul>\n<li>\n<pre><code>   [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象\n</code></pre>\n</li>\n<li>\n<pre><code>   [02] return 的是null或基本数据类型值,则返回新创建的对象\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>总结</p>\n<ul>\n<li>类型匹配才接受-&gt; 对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="16-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">16-对象的创建-简单使用<a class="anchor" href="#16-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">§</a></h2>\n<h3 id="%E5%AF%B9%E8%B1%A1%E5%9C%A8js%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0">对象在js中的体现<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8js%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0">§</a></h3>\n<ul>\n<li>键-值对的集合(key-value)</li>\n<li>属性:在对象内部声明的变量</li>\n<li>方法:在对象内部赋值在属性上的函数</li>\n</ul>\n<h3 id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">对象的创建<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">§</a></h3>\n<ul>\n<li>\n<pre><code>01 字面量\n</code></pre>\n<ul>\n<li>var person = {name:&quot;sz&quot;, age: 18, run: function () {alert(\'跑\');}};</li>\n</ul>\n</li>\n<li>\n<pre><code>02 使用内置构造函数来创建\n</code></pre>\n<ul>\n<li>var obj = new Object();</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C">对象的操作<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C">§</a></h3>\n<ul>\n<li>\n<pre><code>js对象支持动态特性:增加属性(方法) | 删除属性(方法) |修改属性(方法) |查询\n</code></pre>\n</li>\n<li>\n<p>操作对象的属性和方法可以使用两套方式:</p>\n<ul>\n<li>\n<pre><code>01 点语法\n</code></pre>\n</li>\n<li>\n<pre><code>02 中括号[]\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5">操作实践<a class="anchor" href="#%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5">§</a></h3>\n<ul>\n<li>\n<p>创建对象</p>\n</li>\n<li>\n<p>添加属性</p>\n<ul>\n<li>\n<p><a href="http://obj.name">obj.name</a> = \'sz\';</p>\n</li>\n<li>\n<p>系统会自动识别, 如果没有name属性, 则动态添加</p>\n<ul>\n<li>如果有, 则修改</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>查询</p>\n<ul>\n<li>\n<p>一般查询</p>\n<ul>\n<li>console.log(<a href="http://obj.name">obj.name</a>);</li>\n<li>console.log(obj[\'name\']);</li>\n</ul>\n</li>\n<li>\n<p>遍历查询</p>\n<ul>\n<li>\n<p>in 关键字</p>\n<ul>\n<li>\n<ol>\n<li>可以判断对象中是否包含某个属性</li>\n</ol>\n<ul>\n<li>pro in obj</li>\n</ul>\n</li>\n<li>\n<ol start="2">\n<li>可以遍历对象键值对</li>\n</ol>\n<ul>\n<li>for (var key in obj)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>注意</p>\n<ul>\n<li>\n<p>属性的访问形式</p>\n<ul>\n<li>[]</li>\n<li>不能用.</li>\n</ul>\n</li>\n<li>\n<p>in 在数组中的使用</p>\n<ul>\n<li>\n<ol>\n<li>可以判断对象中是否包含某个属性</li>\n</ol>\n<ul>\n<li>pro in obj</li>\n</ul>\n</li>\n<li>\n<ol start="2">\n<li>可以遍历对象键值对</li>\n</ol>\n<ul>\n<li>for (key in arr)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>修改属性</p>\n<ul>\n<li>\n<p><a href="http://obj.name">obj.name</a> = \'sz\';</p>\n</li>\n<li>\n<p>和添加属性的操作完全一样</p>\n</li>\n<li>\n<p>系统会自动识别, 如果没有name属性, 则动态添加</p>\n<ul>\n<li>如果有, 则修改</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>删除</p>\n<ul>\n<li>\n<p>delete关键字</p>\n<ul>\n<li>\n<pre><code>(1) 删除对象中的属性\n</code></pre>\n</li>\n<li>\n<pre><code>(2) 删除没有使用var关键字声明的全局变量\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>注意:</p>\n<ul>\n<li>\n<pre><code>    (1)返回值 布尔类型的值(我们可以通过该值来判断是否删除成功)\n</code></pre>\n</li>\n<li>\n<pre><code>    (2)使用var关键字声明的变量无法被删除\n</code></pre>\n<ul>\n<li>省略var关键字声明的变量, 相当于动态的给window增加一个属性</li>\n<li>window.xxxx = 100;</li>\n<li>这种方式,可以手动删除</li>\n</ul>\n</li>\n<li>\n<pre><code>    (3)删除对象中不存在的属性没有任何变化,但是返回值为true\n</code></pre>\n</li>\n<li>\n<pre><code>    (4)不能删除window下面的全局变量(使用var声明),但是可以删除直接定义在window上面的属性\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%8F%E6%A1%88%E4%BE%8B">17-面向对象小案例<a class="anchor" href="#17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%8F%E6%A1%88%E4%BE%8B">§</a></h2>\n<h3 id="%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97">计算器加减乘除运算<a class="anchor" href="#%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97">§</a></h3>\n<h3 id="%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">面向过程<a class="anchor" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">§</a></h3>\n<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象<a class="anchor" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">§</a></h3>\n<h3 id="%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">链式调用<a class="anchor" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">§</a></h3>'
        } }),
    'head': React.createElement(React.Fragment, null,
        React.createElement("link", { crossOrigin: "anonymous", href: "https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css", integrity: "sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X", rel: "stylesheet" })),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'contentTitle': React.createElement("h1", { key: "0" }, "JavaScript\u57FA\u7840"),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<p>程序 = 算法 + 数据结构</p>\n<p>// 记录到wt第5章</p>\n<h2 id="javascript%E7%9A%84%E7%BB%84%E6%88%90">JavaScript的组成<a class="anchor" href="#javascript%E7%9A%84%E7%BB%84%E6%88%90">§</a></h2>\n<ul>\n<li>\n<p>词法</p>\n<ul>\n<li>直接量，关键字，运算符，标识符，保留字，操作符</li>\n</ul>\n</li>\n<li>\n<p>语法语义</p>\n<ul>\n<li>表达式，语句，函数，对象，模块</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型<a class="anchor" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h2>\n<h3 id="%E5%9F%BA%E6%9C%AC%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><strong>基本(简单)数据类型</strong><a class="anchor" href="#%E5%9F%BA%E6%9C%AC%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h3>\n<ul>\n<li>\n<p><strong>null</strong></p>\n<ul>\n<li>null是基本类型中唯一一个假值，<strong>判断null</strong> <code>!n &amp;&amp; typeof n === &quot;object&quot;</code>，null  是  JavaScript  关键字</li>\n</ul>\n</li>\n<li>\n<p><strong>undefined</strong></p>\n<ul>\n<li>Undefined  类型表示未定义，它的类型只有一个值，就是  undefined</li>\n<li><code>typeof undefined === &quot;undefined&quot;</code>，undefined是一个变量 ，undefined不是关键字，可以作为标识符，**测试chrome80下为， 全局、局部对 undefined 直接赋值已无效，全局 var undefined 无效，局部  <code>var undefined = 1</code>**有效</li>\n<li>已声明还未赋值的变量，是undefined的；没有声明的变量（有的语言中称为undeclared），是<code>ReferenceError: b is not defined</code>，但是typeof仍为undefined；使用typeof检查变量是否被声明，防止直接if()判断报错，也可以使用全局对象<code>if(window.atob)</code>。</li>\n<li>void  运算来把任一一个表达式变成  undefined</li>\n</ul>\n</li>\n<li>\n<p><strong>boolean</strong></p>\n</li>\n<li>\n<p><strong>number</strong></p>\n<ul>\n<li>\n<p><strong>指数</strong>  toExponential() 5e+10 ; toFixed()指定小数部分显示位数，52.toFiex()会报Syntax错误，.运算符会优先识别为数字常量的一部分；toPrecision() 方法指定有效数位的显示位数</p>\n<pre class="language-autoit"><code class="language-autoit">var a <span class="token operator">=</span> <span class="token number">52.55</span><span class="token comment">; a.toPrecision(1) // 5e+1 a.roPrecision(2); // 52 不足补0</span>\n</code></pre>\n</li>\n<li>\n<p><strong>整数</strong> 最大安全整数 <strong>2^53 -1</strong>，ES6中为Number.MAX_SAFE_INTEGER，最小为最大的负值 -2^53 +1，ES6中定义为Number.MAX_SAFE_INTEGER；ES6整数检测，isInteger，isSafeInteger，polyfill用Mach.abs()和MAX_SAFE_INTEGER比大小</p>\n</li>\n<li>\n<p><strong>浮点数</strong> 机器精度 二进制存储位权引起的，<strong>浮点数不等差值 Math.pow(2, -52)，ES6中 Number.EPSION</strong>，最大浮点数Number.MAX_VALUE约为1.798e+308，最小浮点数Number.MIN_VALUE大约5e-324</p>\n</li>\n<li>\n<p>进制</p>\n<ul>\n<li>十进制</li>\n<li>二进制 0b01</li>\n<li>八进制 0o77</li>\n<li>十六进制  0x1F</li>\n</ul>\n</li>\n<li>\n<p>JavaScript中的Number类型有  18437736874454810627(即2^64-2^53+3)  个值。</p>\n</li>\n<li>\n<p>0 === -0 ，ES5区分  +0  和  -0  的方式，正是 检测  1/x  是  Infinity  还是  -Infinity</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>NaN</strong>   设计NaN的操作，都会返回NaN;NaN与任何值都不相等;isNaN 会尝试把类型转换为数字类型。</p>\n<pre class="language-autoit"><code class="language-autoit"> typeof NaN<span class="token comment">; // number NaN != NaN;  isNaN();// true  isNaN(\'\'); // false </span>\n <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment">; // false isNaN(true); // false </span>\n</code></pre>\n<p>全局isNaN会把字符串转化为true，ES6中的新增方法Number.isNaN()</p>\n<pre class="language-autoit"><code class="language-autoit">Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> flase    Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">/</span> <span class="token boolean">false</span>\n</code></pre>\n</li>\n<li>\n<p><strong>string</strong></p>\n<ul>\n<li>\n<p>属性方法：length indexof() concat()  toUpperCase()</p>\n</li>\n<li>\n<p>借用数组的方法</p>\n<pre class="language-autoit"><code class="language-autoit">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">\'-\'</span><span class="token punctuation">)</span>\nArray<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>\nArray<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> fn<span class="token punctuation">)</span>  <span class="token operator">/</span><span class="token operator">/</span> 笨办法，split revserse join，仅适用于不带unicode、特殊字符\n</code></pre>\n</li>\n<li>\n<p>String  有最大长度是  2^53  -  1，charAt、charCodeAt、 length  等方法针对的都是  UTF16  编码。  Unicode  的码点通常用  U+???  来表示，其 中  ???  是十六进制的码点值，0-65536（U+0000  -  U+FFFF）的码点被称为基本字符区域 。星形符号，一个字素，两个length；</p>\n</li>\n<li>\n<p>JavaScript  字符串把每个  UTF16  单元当作一个字符来处理，所以处理非BMP（超出  U+0000  -  U+FFFF  范围） 的字符时，你应该格外小心</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Object</strong></p>\n<ul>\n<li>\n<p>对象的定义是“属性的集合”，属性并非只是简单的名称和值，JavaScript用一组特征（attribute）来描述属性 （property）。属性分为数据属性和访问器属性，二者都是key-value结 构，key可以是字符串或者Symbol类型。</p>\n</li>\n<li>\n<p>函数对象的length是其声明的参数的个数</p>\n</li>\n<li></li>\n<li>\n<p>.  运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得 我们能在基础类型上调用对应对象的方法。</p>\n<ul>\n<li>\n<p>数据属性</p>\n<ul>\n<li>value：就是属性的值。</li>\n<li>writable：决定属性能否被赋值。</li>\n<li>enumerable：决定for in能否枚举该属性。</li>\n<li>configurable：决定该属性能否被删除或者改变特征值。</li>\n</ul>\n</li>\n<li>\n<p>访问器属性 访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值。</p>\n<ul>\n<li>getter：函数或undefined，在取属性值时被调用。</li>\n<li>setter：函数或undefined，在设置属性值时被调用。</li>\n<li>enumerable：决定for in能否枚举该属性。</li>\n<li>configurable：决定该属性能否被删除或者改变特征值</li>\n</ul>\n</li>\n<li>\n<p>获取方式</p>\n<ul>\n<li>Object.getOwnPropertyDescriptors(obj)</li>\n<li>Object.getOwnPropertyDescripter(O,key)</li>\n</ul>\n</li>\n<li>\n<p>Object.getOwnPropertyNames(obj)   Object.getOwnPropertySymbols(obj)  hasOwnProperty()</p>\n</li>\n<li>\n<p>Object.defineProperty 修改访问器属性</p>\n<pre class="language-autoit"><code class="language-autoit">var obj <span class="token operator">=</span> {a<span class="token punctuation">:</span><span class="token string">\'q\'</span><span class="token punctuation">,</span> get <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> {return <span class="token string">\'p\'</span>}<span class="token punctuation">,</span> b<span class="token punctuation">:</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>{}} <span class="token comment">;</span>\nObject<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">\'a\'</span><span class="token punctuation">)</span>\n<span class="token operator">/</span><span class="token operator">/</span> {set<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span> enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> get<span class="token punctuation">:</span> ƒ}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>symbol</strong> 符号</p>\n<ul>\n<li>一切非字符串的对象key的集合，创建  Symbol  的方式是使用全局的  Symbol  函数，  var  mySymbol  =  Symbol(&quot;my  symbol&quot;)。</li>\n<li>Symbol  可以具有字符串类型的描述，但是即使描述相同，Symbol也不相等。</li>\n<li>Symbol.iterator  来自定义  for…of  在对象上的行为。</li>\n<li>typeof Object(Symbol(&quot;a&quot;))[Symbol.toPrimitive] ()  // \'symbol\'</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%A4%E6%96%AD">类型获取和判断<a class="anchor" href="#%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%A4%E6%96%AD">§</a></h2>\n<h3 id="%E8%8E%B7%E5%8F%96%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">获取判断数据类型<a class="anchor" href="#%E8%8E%B7%E5%8F%96%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h3>\n<ul>\n<li>\n<pre><code>运算符:typeof ，适用于基本数据类型\n-         typeof null    ---&gt; object(正确)\n\n-         typeof （function(){}）  function\n</code></pre>\n</li>\n<li>\n<p>value instanceof type  只适用于复杂数据类型</p>\n<ul>\n<li>判断一个实例是否是某一个类型，只要在当前实例的原型链上，用instanceof检测出来的结果都是true，所以在类的原型继承中，最后检测 出来的结果未必是正确的，而且instanceof后面必须更一个对象。\n不能检测基本类型</li>\n</ul>\n</li>\n<li>\n<p>constructor</p>\n<ul>\n<li>每个构造函数的原型对象都有一个constructor属性，并且指向构造函数本身，由于我们可以手动修改 这个属性，所以结果也不是很准确。 不能检测null和undefined</li>\n</ul>\n</li>\n<li>\n<p>Object.prototype.toString.call（最佳方案）</p>\n<ul>\n<li>调用Object原型上的toString()方法，并且通过call改变this指向。返回的是字符串</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E8%A1%A5%E5%85%85">补充<a class="anchor" href="#%E8%A1%A5%E5%85%85">§</a></h3>\n<ul>\n<li>\n<p>null和undefined区别</p>\n<ul>\n<li>\n<p>null表示&quot;没有对象&quot;，即该处不应该有值。</p>\n<ul>\n<li>\n<p>表达是一个对象, 但是没有存放任何引用</p>\n</li>\n<li>\n<p>可以手动赋值</p>\n<ul>\n<li>一般在准备将一个变量赋值为一个对象之前, 先赋值为null</li>\n<li>或者想要释放一个对象的时候</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>undefined表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。</p>\n<ul>\n<li>不需要手动的赋值此值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>可以使用typeof 判断一个变量是否 未定义或者未声明</p>\n<ul>\n<li>\n<p>typeof name</p>\n<ul>\n<li>undefined</li>\n</ul>\n</li>\n<li>\n<p>if (name) {  }</p>\n<ul>\n<li>这种判断是否可行?</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E5%92%8C%E5%92%8C%E8%AF%B4%E6%98%8E">=和==和===说明<a class="anchor" href="#%E5%92%8C%E5%92%8C%E8%AF%B4%E6%98%8E">§</a></h2>\n<h3 id="">=<a class="anchor" href="#">§</a></h3>\n<ul>\n<li>\n<p>赋值操作</p>\n</li>\n<li>\n<p>表达式的返回值就是赋值的数值</p>\n</li>\n<li>\n<p>对条件表达式写法的影响</p>\n<ul>\n<li>if (值 == 变量) { }</li>\n</ul>\n</li>\n</ul>\n<h3 id="-1">==<a class="anchor" href="#-1">§</a></h3>\n<ul>\n<li>\n<p>基本数据类型之间</p>\n<ul>\n<li>判断两个变量 值 是否相等</li>\n</ul>\n</li>\n<li>\n<p>对象之间</p>\n<ul>\n<li>判断内存地址是否相等</li>\n</ul>\n</li>\n<li>\n<p>基本类型和对象之间</p>\n<ul>\n<li>则会将对象转换为基本数据类型数值进行比对</li>\n</ul>\n</li>\n</ul>\n<h3 id="-2">===<a class="anchor" href="#-2">§</a></h3>\n<ul>\n<li>\n<p>基本数据类型之间</p>\n<ul>\n<li>\n<p>判断两个变量 值 是否相等</p>\n<ul>\n<li>且比对类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>对象之间</p>\n<ul>\n<li>判断内存地址是否相等</li>\n</ul>\n</li>\n<li>\n<p>基本类型和对象之间</p>\n<ul>\n<li>\n<p>则会将对象转换为基本数据类型数值进行比对</p>\n<ul>\n<li>且比对类型</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换<a class="anchor" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">§</a></h2>\n<h4 id="stringtonumber">StringToNumber<a class="anchor" href="#stringtonumber">§</a></h4>\n<ul>\n<li>在不传入第二个参数的情况下，parseInt只支持16进制前缀“0x”，而且会忽略非数字字符，也不支持科学 计数法。parseFloat则直接把原字符串作为十进制来解析，Number  是比  parseInt  和  parseFloat  更好的选择。</li>\n</ul>\n<h4 id="%E8%A3%85%E7%AE%B1%E8%BD%AC%E6%8D%A2">装箱转换<a class="anchor" href="#%E8%A3%85%E7%AE%B1%E8%BD%AC%E6%8D%A2">§</a></h4>\n<p>每一类装箱对象皆有私有的  Class  属性，这些属性可以用  Object.prototype.toString  获取：</p>\n<pre class="language-autoit"><code class="language-autoit">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span>\n</code></pre>\n<p>avaScript  中，没有任何方法可以更改私有的  Class  属性，因此Object.prototype.toString  是可以准确识 别对象对应的基本类型的方法，它比  instanceof  更加准确，call本身会产生装箱操作，所以需要配合  typeof  来区分基本类型还是对象类型</p>\n<h4 id="%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2">拆箱转换<a class="anchor" href="#%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2">§</a></h4>\n<ul>\n<li>\n<p>对象到  String  和  Number  的转换都遵循“先拆箱再转换”的规则，拆箱转换会尝试调用  valueOf  和  toString  来获得拆箱后的基本类型。到  String  的拆箱转换会优先调用  toString</p>\n<pre class="language-autoit"><code class="language-autoit">var o <span class="token operator">=</span> {\n            valueOf<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> {\n              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"valueOf"</span><span class="token punctuation">)</span>\n              return {}\n            }<span class="token punctuation">,</span>\n            toString<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> {\n              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"toString"</span><span class="token punctuation">)</span>\n              return {}\n            }<span class="token punctuation">,</span>\n          }\n          o <span class="token operator">*</span> <span class="token number">2</span> \n          <span class="token operator">/</span><span class="token operator">/</span>  valueOf        <span class="token operator">/</span><span class="token operator">/</span>  toString        <span class="token operator">/</span><span class="token operator">/</span>  TypeError\n          <span class="token function">String</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>        \n          <span class="token operator">/</span><span class="token operator">/</span>  toString        <span class="token operator">/</span><span class="token operator">/</span>  valueOf        <span class="token operator">/</span><span class="token operator">/</span>  TypeError\n</code></pre>\n</li>\n<li>\n<p>拆箱转换会尝试调用  valueOf  和  toString  来获得拆箱后的基本类型，</p>\n<pre class="language-autoit"><code class="language-autoit">var o <span class="token operator">=</span> {} <span class="token comment">; </span>\no<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span>  <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">=</span><span class="token operator">></span>  {console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"toPrimitive"</span><span class="token punctuation">)</span><span class="token comment">;  return  "hello"};  </span>\no <span class="token operator">==</span> <span class="token string">\'hello\'</span>  <span class="token operator">/</span><span class="token operator">/</span> <span class="token boolean">true</span>\no <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">\'hello\'</span> <span class="token operator">/</span><span class="token operator">/</span> <span class="token boolean">false</span>\n</code></pre>\n</li>\n</ul>\n<h3 id="%E5%A4%8D%E6%9D%82%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">复杂(复合)数据类型<a class="anchor" href="#%E5%A4%8D%E6%9D%82%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">§</a></h3>\n<ul>\n<li>\n<p>Object 对象类型</p>\n</li>\n<li>\n<p>Array  数组类型    ==&gt;object</p>\n</li>\n<li>\n<p>Date   日期类型    ==&gt;object</p>\n</li>\n<li>\n<p>Math   类型        ==&gt;object</p>\n</li>\n<li>\n<p>Function 函数      ==&gt;function(并非是object)</p>\n</li>\n<li>\n<p>RegExp   正则表达式</p>\n</li>\n<li>\n<p>String  字符串对象类型</p>\n</li>\n<li>\n<p>Number</p>\n</li>\n<li>\n<p>Boolean</p>\n</li>\n</ul>\n<p>Number、String和Boolean，三个构造器是两用的，当跟  new  搭配时，它们产生对象，当直接调用时，它 们表示强制类型转换。Symbol  函数比较特殊，直接用  new  调用它会抛出错误，但它仍然是  Symbol  对象的构造器。</p>\n<h3 id="%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB">基本类型和复杂类型区别<a class="anchor" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB">§</a></h3>\n<ul>\n<li>\n<p>存储方式不同</p>\n<ul>\n<li>\n<p>堆区和栈区</p>\n<ul>\n<li>\n<p>栈区特点</p>\n<ul>\n<li>\n<p>操作性能高, 速度快</p>\n</li>\n<li>\n<p>存储量小</p>\n</li>\n<li>\n<p>所以:</p>\n<ul>\n<li>一般存储操作频率较高, 生命周期较短, 占用空间较小的数据</li>\n<li>基本数据类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>堆区特点</p>\n<ul>\n<li>\n<p>操作性能低, 速度慢</p>\n</li>\n<li>\n<p>存储量大</p>\n</li>\n<li>\n<p>所以</p>\n<ul>\n<li>\n<p>一般存储  操作频率较低, 生命周期比较长, 占用空间比较大的数据</p>\n</li>\n<li>\n<p>复杂数据类型</p>\n<ul>\n<li>对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>图解</p>\n</li>\n</ul>\n</li>\n<li>\n<p>操作方式的不同</p>\n<ul>\n<li>\n<p>划分</p>\n<ul>\n<li>\n<p>值类型  string  number boolean undefined null(*)</p>\n</li>\n<li>\n<p>引用类型</p>\n<ul>\n<li>\n<pre><code>Object类型,以下类型其本质都是object类型，Function ，Array， Date， String，Number，Boolean\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>值&amp;引用</p>\n<ul>\n<li>\n<p>赋值</p>\n<ul>\n<li>值类型赋值</li>\n<li>引用类型赋值</li>\n</ul>\n</li>\n<li>\n<p>传递</p>\n<ul>\n<li>函数中的参数传递</li>\n</ul>\n</li>\n<li>\n<p>技巧</p>\n<ul>\n<li>脑中有图</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id="%E6%95%B0%E7%BB%84">数组<a class="anchor" href="#%E6%95%B0%E7%BB%84">§</a></h4>\n<p>字符串键值如果能强制转换为十进制数字，则会被当作数字索引。</p>\n<pre class="language-autoit"><code class="language-autoit">var a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment">; a[\'8\'] = 99; a.length // 9</span>\n</code></pre>\n<h5 id="%E7%B1%BB%E6%95%B0%E7%BB%84">类数组<a class="anchor" href="#%E7%B1%BB%E6%95%B0%E7%BB%84">§</a></h5>\n<p>DOM元素列表，arguments对象，转数组</p>\n<ul>\n<li>\n<p>Array.prototype.slice.call(arguments)</p>\n</li>\n<li>\n<p>ES6中的 Array.from(args)</p>\n</li>\n<li>\n<p>核心</p>\n</li>\n<li>\n<p>注意:</p>\n<ul>\n<li>\n<p>定义的仅仅是语言基础</p>\n<ul>\n<li>语法</li>\n<li>类型</li>\n<li>语句</li>\n<li>关键字</li>\n<li>保留字</li>\n<li>操作符</li>\n<li>对象</li>\n<li>...</li>\n</ul>\n</li>\n<li>\n<p>宿主环境提供了该语言的基本实现和扩展</p>\n<ul>\n<li>比如DOM</li>\n</ul>\n</li>\n<li>\n<p>与Web浏览器没有依赖关系</p>\n<ul>\n<li>浏览器只是ECMAScript实现的宿主环境之一</li>\n</ul>\n</li>\n<li>\n<p>其他宿主环境</p>\n<ul>\n<li>\n<p>Node</p>\n<ul>\n<li>服务器端的JavaScript平台</li>\n</ul>\n</li>\n<li>\n<p>Adobe Flash</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="dom">DOM<a class="anchor" href="#dom">§</a></h3>\n<ul>\n<li>\n<p>文档对象模型</p>\n</li>\n<li>\n<p>功能</p>\n<ul>\n<li>\n<ol>\n<li>把整个页面映射成为一个多层节点结构</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>然后提供了一套对这些节点(内容)增删改查的方法</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>DOM级别</p>\n<ul>\n<li>\n<p>DOM1</p>\n<ul>\n<li>\n<p>DOM Core</p>\n<ul>\n<li>如何映射基于XML的文档结构</li>\n</ul>\n</li>\n<li>\n<p>DOM HTML</p>\n<ul>\n<li>添加了针对HTML的对象和方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>DOM2</p>\n<ul>\n<li>\n<p>扩充了鼠标和用户界面事件, 范围,遍历等细分模块</p>\n</li>\n<li>\n<p>通过对象接口增加了对CSS的支持</p>\n</li>\n<li>\n<p>具体</p>\n<ul>\n<li>\n<p>DOM视图</p>\n<ul>\n<li>定义了跟踪不同文档视图的接口</li>\n</ul>\n</li>\n<li>\n<p>DOM事件</p>\n<ul>\n<li>定义了事件和事件处理的接口</li>\n</ul>\n</li>\n<li>\n<p>DOM样式</p>\n<ul>\n<li>定义了基于CSS, 操作元素样式的接口</li>\n</ul>\n</li>\n<li>\n<p>DOM遍历和范围</p>\n<ul>\n<li>定义了遍历和操作文档树的接口</li>\n<li>新增了验证文档的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>DOM3</p>\n<ul>\n<li>引入了以统一方式加载和保存文档的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>注意</p>\n<ul>\n<li>针对于XML但经过扩展,用于HTML的应用程序编程接口(API)</li>\n<li>不只是针对于JavaScript的, 很多其他语言也实现了DOM</li>\n</ul>\n</li>\n</ul>\n<h3 id="bom">BOM<a class="anchor" href="#bom">§</a></h3>\n<ul>\n<li>\n<p>浏览器对象模型</p>\n</li>\n<li>\n<p>作用</p>\n<ul>\n<li>处理浏览器窗口和框架</li>\n<li>习惯于把针对于浏览器操作的JS扩展也归为BOM</li>\n</ul>\n</li>\n<li>\n<p>具体功能</p>\n<ul>\n<li>弹出新浏览器窗口的功能</li>\n<li>移动,缩放和关闭浏览器窗口的功能</li>\n<li>提供浏览器详细信息的navigator对象</li>\n<li>提供浏览器所加载页面的详细信息的location对象</li>\n<li>提供用户显示器分辨率详细信息的screen对象</li>\n<li>对cookie的支持</li>\n<li>XMLHttpRequest -- ActiveXObject</li>\n</ul>\n</li>\n</ul>\n<h3 id="-3"><a class="anchor" href="#-3">§</a></h3>\n<hr>\n<hr>\n<h2 id="05-ecmascript-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">05-ECMAScript-关系运算符<a class="anchor" href="#05-ecmascript-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">§</a></h2>\n<h3 id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E6%9E%9C%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">关系运算符(结果是布尔类型)<a class="anchor" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E6%9E%9C%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">§</a></h3>\n<h3 id="%E5%A4%A7%E4%BA%8E">大于(&gt;)<a class="anchor" href="#%E5%A4%A7%E4%BA%8E">§</a></h3>\n<h3 id="%E5%B0%8F%E4%BA%8E">小于(&lt;)<a class="anchor" href="#%E5%B0%8F%E4%BA%8E">§</a></h3>\n<h3 id="%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%B0%8F%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E">小于等于(&lt;=) 小于或者是等于<a class="anchor" href="#%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%B0%8F%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E">§</a></h3>\n<h3 id="%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%A4%A7%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E">大于等于(&gt;=) 大于或者是等于<a class="anchor" href="#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%A4%A7%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E">§</a></h3>\n<h3 id="%E4%B8%8D%E7%AD%89%E4%BA%8E">不等于(!=)<a class="anchor" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E">§</a></h3>\n<h3 id="%E6%B3%A8%E6%84%8F">注意:<a class="anchor" href="#%E6%B3%A8%E6%84%8F">§</a></h3>\n<ul>\n<li>\n<p>基本数据类型之间</p>\n<ul>\n<li>转换成同类型进行值比对</li>\n</ul>\n</li>\n<li>\n<p>对象类型之间</p>\n<ul>\n<li>\n<p>比如数组</p>\n</li>\n<li>\n<blockquote>\n<p>&lt; &gt;= &lt;=</p>\n</blockquote>\n<ul>\n<li>会转换成值进行比对</li>\n</ul>\n</li>\n<li>\n<p>!=</p>\n<ul>\n<li>\n<p>与==相反</p>\n<ul>\n<li>比对的是内存地址</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>基本数据类型和对象类型之间</p>\n<ul>\n<li>则会将对象转换为基本数据类型数值进行比对</li>\n</ul>\n</li>\n</ul>\n<h2 id="06-ecmascript-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">06-ECMAScript-逻辑运算符<a class="anchor" href="#06-ecmascript-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">§</a></h2>\n<h3 id="01-%E9%80%BB%E8%BE%91%E9%9D%9E">01 逻辑非<a class="anchor" href="#01-%E9%80%BB%E8%BE%91%E9%9D%9E">§</a></h3>\n<ul>\n<li>\n<pre><code>符号:!\n</code></pre>\n</li>\n<li>\n<pre><code>操作符: !表达式\n</code></pre>\n</li>\n<li>\n<pre><code>结果:布尔类型的值,要么是true要么是false\n</code></pre>\n</li>\n<li>\n<p>0 \'\' false null undefined</p>\n<ul>\n<li>取反全为true</li>\n</ul>\n</li>\n</ul>\n<h3 id="02-%E9%80%BB%E8%BE%91%E4%B8%8E">02 逻辑与<a class="anchor" href="#02-%E9%80%BB%E8%BE%91%E4%B8%8E">§</a></h3>\n<ul>\n<li>\n<pre><code>符号:&amp;&amp;\n</code></pre>\n</li>\n<li>\n<pre><code>操作符:表达式1 &amp;&amp; 表达式2\n</code></pre>\n</li>\n</ul>\n<h3 id="03-%E9%80%BB%E8%BE%91%E6%88%96">03 逻辑或<a class="anchor" href="#03-%E9%80%BB%E8%BE%91%E6%88%96">§</a></h3>\n<ul>\n<li>\n<pre><code>符号:||\n</code></pre>\n</li>\n<li>\n<pre><code>操作符:表达式1 || 表达式2\n</code></pre>\n</li>\n</ul>\n<h3 id="%E6%B3%A8%E6%84%8F-1">注意:<a class="anchor" href="#%E6%B3%A8%E6%84%8F-1">§</a></h3>\n<ul>\n<li>\n<ol>\n<li>注意逻辑与和逻辑或的返回值, 并非boolean类型</li>\n</ol>\n<ul>\n<li>\n<p>逻辑与</p>\n<ul>\n<li>\n<pre><code>一假全假\n</code></pre>\n<ul>\n<li>\n<pre><code> 如果表达式1为假,那么就返回表达式1,否则就返回表达式2\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>逻辑或</p>\n<ul>\n<li>\n<pre><code>一真全真\n</code></pre>\n<ul>\n<li>\n<pre><code>    如果表达式1为真,那么就返回表达式1,否则就返回表达式2\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ol start="2">\n<li>逻辑与和逻辑或也被称为短路运算符</li>\n</ol>\n<ul>\n<li>\n<p>逻辑与</p>\n<ul>\n<li>\n<p>一假全假</p>\n<ul>\n<li>第一个假的,后面不会再进行执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>逻辑或</p>\n<ul>\n<li>\n<p>一真全真</p>\n<ul>\n<li>第一个真的, 后面不会再执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="07-ecmascript-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF">07-ECMAScript-分支和循环<a class="anchor" href="#07-ecmascript-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF">§</a></h2>\n<h3 id="%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">条件结构<a class="anchor" href="#%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">§</a></h3>\n<ul>\n<li>\n<p>if..else</p>\n</li>\n<li>\n<p>?:</p>\n</li>\n<li>\n<p>switch..case</p>\n</li>\n<li>\n<p>案例</p>\n<ul>\n<li>分数级别</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">循环结构<a class="anchor" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">§</a></h3>\n<ul>\n<li>\n<p>for循环</p>\n</li>\n<li>\n<p>for...in(主要用于遍历对象)</p>\n</li>\n<li>\n<p>while</p>\n</li>\n<li>\n<p>do...while(至少会执行一次)</p>\n</li>\n<li>\n<p>案例</p>\n<ul>\n<li>99乘法表</li>\n<li>阶乘</li>\n</ul>\n</li>\n<li>\n<p>注意:</p>\n<ul>\n<li>break</li>\n<li>continue</li>\n<li>label</li>\n</ul>\n</li>\n</ul>\n<h2 id="08-ecmascript-%E5%87%BD%E6%95%B0">08-ECMAScript-函数<a class="anchor" href="#08-ecmascript-%E5%87%BD%E6%95%B0">§</a></h2>\n<h3 id="1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA">1. 函数的几种创建?<a class="anchor" href="#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA">§</a></h3>\n<ul>\n<li>\n<pre><code>01 声明函数\n</code></pre>\n<ul>\n<li>\n<pre><code>function 函数名称 (形参1,形参2)\n</code></pre>\n</li>\n<li>\n<pre><code>{\n</code></pre>\n</li>\n<li>\n<pre><code>    //函数体\n</code></pre>\n</li>\n<li>\n<pre><code>}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<pre><code>02 函数表达式\n</code></pre>\n<ul>\n<li>\n<p>01 匿名函数</p>\n<ul>\n<li>\n<pre><code>var func01 = function (){\n</code></pre>\n</li>\n<li>\n<pre><code>};\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>02 命名的函数表达式</p>\n<ul>\n<li>var func02 = function func(){</li>\n<li>\n<pre><code>};\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<pre><code>03 使用构造函数创建函数对象\n</code></pre>\n<ul>\n<li>\n<pre><code>var func02 = new Function(&quot;console.log(\'demo\');&quot;);\n</code></pre>\n</li>\n<li>\n<pre><code>func02();\n</code></pre>\n</li>\n<li>\n<p>可以传递N个参数</p>\n<ul>\n<li>会把最后一个参数, 当做函数体;</li>\n<li>其他参数当做函数形参</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="2-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7">2. 函数使用技巧<a class="anchor" href="#2-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7">§</a></h3>\n<ul>\n<li>\n<p>形参和arguments</p>\n<ul>\n<li>该参数是一个类似于数组的结构（可以像数组一样遍历 + 还可以使用下标来访问数据），但是并不是数组。</li>\n<li>\n<pre><code>          01 函数调用的时候，会把实参的值赋值给形参，而且会使用arguments来接收实参\n</code></pre>\n</li>\n<li>\n<pre><code>          02 如果实参的个数超过形参的个数，那么可以通过arguments来获取超出的数据\n</code></pre>\n</li>\n<li>\n<pre><code>          03 如果实参的格式小于形参的个数，那么不足的全部设置为undefined\n</code></pre>\n</li>\n<li>两者之间是关联的关系</li>\n</ul>\n</li>\n<li>\n<p>length属性</p>\n<ul>\n<li>\n<p>函数名.length</p>\n<ul>\n<li>形参的长度（个数）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>name属性</p>\n<ul>\n<li>函数名称</li>\n</ul>\n</li>\n<li>\n<p>函数重载</p>\n<ul>\n<li>\n<p>概念</p>\n<ul>\n<li>函数名相同, 但是根据传递的参数不同可以实现不同的功能</li>\n</ul>\n</li>\n<li>\n<p>例如</p>\n<ul>\n<li>function sum(a, b)</li>\n<li>function sum(a, b, c)</li>\n<li>可以同时存在</li>\n</ul>\n</li>\n<li>\n<p>但是:js没有函数重载!</p>\n<ul>\n<li>但是可以通过arguments个数来模拟重载</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>js模板使用</p>\n</li>\n</ul>\n<h3 id="3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%AB%E6%B3%95">3. 函数的几种叫法?<a class="anchor" href="#3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%AB%E6%B3%95">§</a></h3>\n<ul>\n<li>\n<p>函数</p>\n<ul>\n<li>命名函数</li>\n<li>匿名函数</li>\n</ul>\n</li>\n<li>\n<p>闭包</p>\n<ul>\n<li>\n<p>可以在其他函数作用域之外访问其他函数内部变量的函数</p>\n<ul>\n<li>由函数内部返回给外界的函数</li>\n<li>由外界传递到函数内部的函数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>方法</p>\n<ul>\n<li>\n<p>有宿主</p>\n<ul>\n<li>静态方法</li>\n<li>实例方法</li>\n</ul>\n</li>\n<li>\n<p>需要通过宿主来调用</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="09-ecmascript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98">09-ECMAScript-作用域问题<a class="anchor" href="#09-ecmascript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98">§</a></h2>\n<h3 id="%E6%A6%82%E5%BF%B5%E6%9F%90%E4%B8%AA%E5%8F%98%E9%87%8F%E6%9C%89%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%8C%83%E5%9B%B4">概念：某个变量有（起）作用的范围<a class="anchor" href="#%E6%A6%82%E5%BF%B5%E6%9F%90%E4%B8%AA%E5%8F%98%E9%87%8F%E6%9C%89%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%8C%83%E5%9B%B4">§</a></h3>\n<h3 id="js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">js中的作用域<a class="anchor" href="#js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">§</a></h3>\n<ul>\n<li>\n<p>01-script标签构成的全局作用域</p>\n</li>\n<li>\n<p>02-块级作用域</p>\n<ul>\n<li>在其他语言中, 由{}包含的代码块都有自己的作用域</li>\n<li>在其他语言中，有块级作用域，但是在js中没有块级作用域</li>\n</ul>\n</li>\n<li>\n<p>03-在js中函数是唯一一个可以创建作用域的对象</p>\n<ul>\n<li>\n<p>注意:</p>\n<ul>\n<li>如果没有通过var关键字声明变量, 则为全局变量</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">作用域链<a class="anchor" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">§</a></h3>\n<ul>\n<li>01 js中函数可以创建作用域</li>\n<li>02 js中的函数中可以声明函数</li>\n<li>03 函数内部的函数中又可以声明函数</li>\n<li>04 以上,会形成一个链式的结构,这个是作用域链</li>\n</ul>\n<h3 id="%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99">变量查找原则<a class="anchor" href="#%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99">§</a></h3>\n<ul>\n<li>就近原则</li>\n<li>从内到外</li>\n</ul>\n<h2 id="10-ecmascript-%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87">10-ECMAScript-变量和函数提升<a class="anchor" href="#10-ecmascript-%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87">§</a></h2>\n<h3 id="js%E7%9A%84%E6%89%A7%E8%A1%8C">js的执行：<a class="anchor" href="#js%E7%9A%84%E6%89%A7%E8%A1%8C">§</a></h3>\n<ul>\n<li>\n<pre><code>01 预解析阶段  变量和函数的提升（声明）\n</code></pre>\n</li>\n<li>\n<pre><code>02 具体的执行阶段\n</code></pre>\n</li>\n</ul>\n<h3 id="%E8%A7%84%E5%88%99">规则<a class="anchor" href="#%E8%A7%84%E5%88%99">§</a></h3>\n<ul>\n<li>\n<p>0-会把变量的声明提升到当前作用域的最前面</p>\n<ul>\n<li>赋值放在原位置不动</li>\n</ul>\n</li>\n<li>\n<p>1-会把函数声明提升到当前作用域前面</p>\n<ul>\n<li>\n<p>紧接着被提升过的其他声明</p>\n</li>\n<li>\n<p>注意:</p>\n<ul>\n<li>\n<p>函数的声明包含了函数体</p>\n</li>\n<li>\n<p>如果是函数的表达式</p>\n<ul>\n<li>只会把var 变量的名称(函数)提升到当前作用域的最顶端</li>\n</ul>\n</li>\n<li>\n<p>特例写法</p>\n<ul>\n<li>\n<p>if (condition) {\nfunction a() {alert(\'1\')};\n}else {\nfunction a() {alert(\'2\')};\n}</p>\n<ul>\n<li>不要这样写!!!</li>\n</ul>\n</li>\n<li>\n<p>使用函数表达式的形式修正</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>2-变量和变量同名的情况:后面的变量会把前面的变量覆盖</p>\n</li>\n<li>\n<p>3-函数和函数同名的情况,后面的会把前面的覆盖</p>\n</li>\n<li>\n<p>4-函数和变量同名的情况:</p>\n<ul>\n<li>变量的声明不会覆盖函数的声明</li>\n</ul>\n</li>\n<li>\n<p>5-变量提升无法脱离所在作用域</p>\n</li>\n</ul>\n<h3 id="%E6%B5%8B%E8%AF%95">测试<a class="anchor" href="#%E6%B5%8B%E8%AF%95">§</a></h3>\n<ul>\n<li>\n<p>测试1</p>\n<pre><code>function foo() {\n    var num = 123;\n    console.log(num);\n}\n\nfoo();          \nconsole.log(num); \n</code></pre>\n</li>\n<li>\n<p>测试2</p>\n<pre><code>var scope = &quot;global&quot;;\nfoo();\nfunction foo() {\n    console.log(scope);\n    var scope = &quot;local&quot;;\n    console.log(scope);\n}\nconsole.log(scope);\n</code></pre>\n</li>\n<li>\n<p>测试3</p>\n<pre><code>function f1(){\n    if(&quot;a&quot; in window){\n        var a = 10;\n    }\n    console.log(a);\n}\nf1();\n</code></pre>\n</li>\n<li>\n<p>测试4</p>\n<pre><code>if(&quot;a&quot; in window){\n    var a = 10;\n}\nconsole.log(a);\n</code></pre>\n</li>\n<li>\n<p>测试5</p>\n<pre><code>var foo = 1;\nfunction bar() {\n    if(!foo)\n    {\n        var foo = 10;\n    }\n    alert(foo);\n}\nbar();\n</code></pre>\n</li>\n<li>\n<p>绘制作用域图</p>\n<pre><code>var a = 10;\nfunction f1(){\n    function f2(){\n        var d = &quot;demoD&quot;;\n    }\n}\n\nfunction f3(){\n    function f4(){\n    }\n    var b = &quot;demoB&quot;;\n    function f5(){\n        var c = &quot;demoC&quot;\n    }\n}\n</code></pre>\n</li>\n</ul>\n<h2 id="11-ecmascript-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">11-ECMAScript-异常处理<a class="anchor" href="#11-ecmascript-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">§</a></h2>\n<h3 id="%E5%9C%BA%E6%99%AF">场景<a class="anchor" href="#%E5%9C%BA%E6%99%AF">§</a></h3>\n<ul>\n<li>正常情况下,如果程序出现了错误或者是异常,那么该行代码后面的所有代码都无法得到执行</li>\n<li>但是,有些时候我们需要保证即便程序出现了问题,后面的代码也能够正常执行,这种情况就可以使用异常捕获结构</li>\n</ul>\n<h3 id="%E4%BD%BF%E7%94%A8">使用<a class="anchor" href="#%E4%BD%BF%E7%94%A8">§</a></h3>\n<ul>\n<li>\n<p>抛出异常</p>\n<ul>\n<li>\n<p>throw</p>\n<ul>\n<li>字符串</li>\n<li>对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>捕捉异常</p>\n<ul>\n<li>\n<pre><code>try{\n</code></pre>\n</li>\n<li>\n<pre><code>    //可能出错的代码\n</code></pre>\n</li>\n<li>\n<pre><code>}catch (e){\n</code></pre>\n</li>\n<li>\n<pre><code>    //出错了就执行这个代码块\n</code></pre>\n</li>\n<li>\n<pre><code>}\n</code></pre>\n</li>\n<li>\n<pre><code>finally\n</code></pre>\n</li>\n<li>\n<pre><code>{\n</code></pre>\n</li>\n<li>\n<pre><code>    //不管是否出错,都会执行这里的代码块\n</code></pre>\n</li>\n<li>\n<pre><code>    //一般在前端开发中不会使用,多多用于后端开发Node.js 主要用于在最后释放资源\n</code></pre>\n</li>\n<li>\n<pre><code>}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="12-dom-%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">12-DOM-操作(增删改查)<a class="anchor" href="#12-dom-%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">§</a></h2>\n<h3 id="%E5%A2%9E%E5%8A%A0">增加<a class="anchor" href="#%E5%A2%9E%E5%8A%A0">§</a></h3>\n<ul>\n<li>\n<p>创建tag</p>\n<ul>\n<li>document.createElement(&quot;div&quot;);</li>\n</ul>\n</li>\n<li>\n<p>添加tag</p>\n<ul>\n<li>appendChild</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E5%88%A0%E9%99%A4">删除<a class="anchor" href="#%E5%88%A0%E9%99%A4">§</a></h3>\n<ul>\n<li>parent.removeChild(child);</li>\n</ul>\n<h3 id="%E4%BF%AE%E6%94%B9">修改<a class="anchor" href="#%E4%BF%AE%E6%94%B9">§</a></h3>\n<ul>\n<li>\n<p>主要只修改内部属性</p>\n<ul>\n<li>innerHTML</li>\n<li>style</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E6%9F%A5%E8%AF%A2">查询<a class="anchor" href="#%E6%9F%A5%E8%AF%A2">§</a></h3>\n<ul>\n<li>根据标签查询</li>\n<li>根据ID查询</li>\n<li>根据class查询</li>\n<li>查询所有</li>\n<li>...</li>\n</ul>\n<h2 id="13-bom-%E6%93%8D%E4%BD%9C">13-BOM-操作<a class="anchor" href="#13-bom-%E6%93%8D%E4%BD%9C">§</a></h2>\n<h3 id="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">浏览器对象模型<a class="anchor" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B">§</a></h3>\n<h3 id="%E4%BD%9C%E7%94%A8">作用<a class="anchor" href="#%E4%BD%9C%E7%94%A8">§</a></h3>\n<ul>\n<li>处理浏览器窗口和框架</li>\n<li>习惯于把针对于浏览器操作的JS扩展也归为BOM</li>\n</ul>\n<h3 id="%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD">具体功能<a class="anchor" href="#%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD">§</a></h3>\n<ul>\n<li>弹出新浏览器窗口的功能</li>\n<li>移动,缩放和关闭浏览器窗口的功能</li>\n<li>提供浏览器详细信息的navigator对象</li>\n<li>提供浏览器所加载页面的详细信息的location对象</li>\n<li>提供用户显示器分辨率详细信息的screen对象</li>\n<li>对cookie的支持</li>\n<li>XMLHttpRequest -- ActiveXObject</li>\n</ul>\n<h3 id="%E9%87%8D%E8%A6%81%E5%AF%B9%E8%B1%A1">重要对象<a class="anchor" href="#%E9%87%8D%E8%A6%81%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>\n<p>window</p>\n<ul>\n<li>\n<p>标识浏览器的一个实例</p>\n</li>\n<li>\n<p>全局作用域</p>\n<ul>\n<li>全局作用域中的变量或者函数都会变成window的属性或者方法</li>\n</ul>\n</li>\n<li>\n<p>窗口位置</p>\n<ul>\n<li>moveTo</li>\n<li>moveBy</li>\n<li>可能被禁用</li>\n</ul>\n</li>\n<li>\n<p>窗口大小</p>\n<ul>\n<li>resizeTo</li>\n<li>resizeBy</li>\n<li>可能被禁用</li>\n</ul>\n</li>\n<li>\n<p>导航和打开窗口</p>\n<ul>\n<li>\n<p>open</p>\n<ul>\n<li>\n<pre><code>参数1: 需要加载的URL\n</code></pre>\n</li>\n<li>\n<pre><code>参数2: 窗口目标\n</code></pre>\n<ul>\n<li>窗口名称</li>\n<li>_self</li>\n<li>_parent</li>\n<li>_top</li>\n<li>_blank</li>\n</ul>\n</li>\n<li>\n<pre><code>参数3: 一个特性字符串(,分割)\n</code></pre>\n<ul>\n<li>\n<p>fullScreen</p>\n<ul>\n<li>yes/no</li>\n</ul>\n</li>\n<li>\n<p>width</p>\n</li>\n<li>\n<p>height</p>\n</li>\n<li>\n<p>left</p>\n</li>\n<li>\n<p>top</p>\n</li>\n<li>\n<p>toolbar</p>\n</li>\n<li>\n<p>status</p>\n</li>\n<li>\n<p>resizable</p>\n</li>\n</ul>\n</li>\n<li>\n<pre><code>参数4: 是否取代浏览器历史集中中当前加载页面的Boolean值\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>间歇调用和超时调用</p>\n<ul>\n<li>setInterval</li>\n<li>setTimeout</li>\n</ul>\n</li>\n<li>\n<p>系统对话框</p>\n<ul>\n<li>\n<p>confirm</p>\n<ul>\n<li>确认框</li>\n</ul>\n</li>\n<li>\n<p>alert</p>\n<ul>\n<li>消息框</li>\n</ul>\n</li>\n<li>\n<p>prompt</p>\n<ul>\n<li>输入框</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>location</p>\n<ul>\n<li>\n<p>提供了与当前窗口中加载的文档有关的信息, 还提供了一些导航功能</p>\n</li>\n<li>\n<p>window.location === document.location</p>\n</li>\n<li>\n<p>常用属性</p>\n<ul>\n<li>\n<p>hash</p>\n</li>\n<li>\n<p>href</p>\n<ul>\n<li><a href="http://www.520it.com:80/person/sz.php?param1=name&amp;param2=age">http://www.520it.com:80/person/sz.php?param1=name&amp;param2=age</a></li>\n</ul>\n</li>\n<li>\n<p>protocol</p>\n<ul>\n<li>http:</li>\n</ul>\n</li>\n<li>\n<p>host</p>\n<ul>\n<li><a href="http://www.520it.com:80">www.520it.com:80</a></li>\n</ul>\n</li>\n<li>\n<p>hostname</p>\n<ul>\n<li><a href="http://www.520it.com">www.520it.com</a></li>\n</ul>\n</li>\n<li>\n<p>port</p>\n<ul>\n<li>80</li>\n</ul>\n</li>\n<li>\n<p>pathname</p>\n<ul>\n<li>/person/</li>\n</ul>\n</li>\n<li>\n<p>search</p>\n<ul>\n<li>?param1=name&amp;param2=age</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>查询字符串参数</p>\n<ul>\n<li>查询串需要我们自己解析</li>\n</ul>\n</li>\n<li>\n<p>位置操作</p>\n<ul>\n<li>\n<p>window.location.assign(url)</p>\n</li>\n<li>\n<p>window.location =url</p>\n</li>\n<li>\n<p>window.location.href =url</p>\n</li>\n<li>\n<p>注意</p>\n<ul>\n<li>\n<p>以上三句代码, 效果等同, 都会重新加载最新url</p>\n</li>\n<li>\n<p>另外, 修改了location的属性, 也会触发重新加载网页</p>\n<ul>\n<li>hash除外</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>navigator</p>\n<ul>\n<li>\n<p>识别客户端信息的事实标准</p>\n<ul>\n<li>\n<p>appCodeName</p>\n<ul>\n<li>浏览器名称</li>\n</ul>\n</li>\n<li>\n<p>appName</p>\n<ul>\n<li>完整的浏览器名称</li>\n</ul>\n</li>\n<li>\n<p>appVersion</p>\n<ul>\n<li>浏览器版本</li>\n</ul>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>screen</p>\n<ul>\n<li>\n<p>浏览器窗口的描述信息</p>\n<ul>\n<li>width/height</li>\n<li>top/left</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>history</p>\n<ul>\n<li>\n<p>上网的历史记录</p>\n</li>\n<li>\n<p>go(num)</p>\n<ul>\n<li>前进/后退几页</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">14-面向对象-相关概念<a class="anchor" href="#14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">§</a></h2>\n<h3 id="01-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1">01-什么是对象?<a class="anchor" href="#01-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>\n<p>万物皆对象</p>\n</li>\n<li>\n<pre><code>对象是具体物体\n</code></pre>\n<ul>\n<li>拥有属性</li>\n<li>拥有行为</li>\n<li>把很多零散的东西, 封装成为一个整体</li>\n</ul>\n</li>\n<li>\n<pre><code>举例: \n</code></pre>\n<ul>\n<li>\n<p>王二小</p>\n<ul>\n<li>\n<p>属性</p>\n<ul>\n<li>姓名</li>\n<li>年龄</li>\n<li>身高</li>\n<li>体重</li>\n<li>...</li>\n</ul>\n</li>\n<li>\n<p>行为</p>\n<ul>\n<li>走路</li>\n<li>吃饭</li>\n<li>放羊</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>DOM节点</p>\n<ul>\n<li>\n<p>属性</p>\n<ul>\n<li>innerHTML</li>\n<li>innerTEXT</li>\n<li>style</li>\n<li>...</li>\n</ul>\n</li>\n<li>\n<p>行为</p>\n<ul>\n<li>removeChild(child);</li>\n<li>appendChild()</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">02-面向对象-面向过程<a class="anchor" href="#02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">§</a></h3>\n<ul>\n<li>\n<pre><code>都是一种解决问题的思路(思想)\n</code></pre>\n</li>\n<li>\n<pre><code>面向过程\n</code></pre>\n<ul>\n<li>在解决问题的时候,关注的是解决问题需要的一个接着一个的过程(步骤)</li>\n</ul>\n</li>\n<li>\n<pre><code>面向对象\n</code></pre>\n<ul>\n<li>在解决问题的时候,关注的是解决问题所需要的对象.</li>\n</ul>\n</li>\n<li>\n<p>对比</p>\n<ul>\n<li>\n<p>面向对象和面向过程都是解决问题的一种方式(思想)</p>\n<ul>\n<li>面向对象本身是对面向过程的封装.</li>\n</ul>\n</li>\n<li>\n<p>面向对象编程最重要的什么?</p>\n<ul>\n<li>\n<p>找到对象, 确定对象属性和行为</p>\n</li>\n<li>\n<p>小案例</p>\n<ul>\n<li>\n<p>做好饭之后洗碗</p>\n<ul>\n<li>\n<p>面向过程</p>\n<ul>\n<li>\n<p>你</p>\n<ul>\n<li>洗菜</li>\n<li>点火倒油</li>\n<li>放菜,材料</li>\n<li>翻炒</li>\n<li>盛出</li>\n<li>放水</li>\n<li>放碗</li>\n<li>倒洗洁精</li>\n<li>开始刷</li>\n<li>擦干水</li>\n<li>摆放好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>面向对象</p>\n<ul>\n<li>\n<p>你</p>\n<ul>\n<li>\n<p>对象</p>\n<ul>\n<li>\n<p>技能1: 做饭</p>\n<ul>\n<li>洗菜</li>\n<li>点火倒油</li>\n<li>放菜,材料</li>\n<li>翻炒</li>\n<li>盛出</li>\n</ul>\n</li>\n<li>\n<p>技能2:洗碗</p>\n<ul>\n<li>放水</li>\n<li>放碗</li>\n<li>倒洗洁精</li>\n<li>开始刷</li>\n<li>擦干水</li>\n<li>摆放好</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>你</p>\n<ul>\n<li>\n<p>对象</p>\n<ul>\n<li>\n<p>技能1: 做饭</p>\n<ul>\n<li>\n<p>放菜,材料</p>\n</li>\n<li>\n<p>自动炒菜机</p>\n<ul>\n<li>搅拌</li>\n<li>翻炒</li>\n<li>监测火候</li>\n</ul>\n</li>\n<li>\n<p>盛出</p>\n</li>\n</ul>\n</li>\n<li>\n<p>技能2:洗碗</p>\n<ul>\n<li>\n<p>放水/放碗</p>\n</li>\n<li>\n<p>自动洗碗机</p>\n<ul>\n<li>倒洗洁精</li>\n<li>开始刷</li>\n<li>擦干水</li>\n</ul>\n</li>\n<li>\n<p>摆放好</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>面向对象的好处</p>\n<ul>\n<li>\n<pre><code>01 更方便\n</code></pre>\n</li>\n<li>\n<pre><code>02 复用性会更好\n</code></pre>\n</li>\n<li>\n<pre><code>03 高内聚和低耦合\n</code></pre>\n</li>\n<li>\n<pre><code>04 冗余(重复的东西)--&gt;封装(提取相同的部分作为函数体,抽取不同的部分作为参数)\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F">15-面向对象-创建对象的方式<a class="anchor" href="#15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F">§</a></h2>\n<h3 id="%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">字面量的方式创建对象<a class="anchor" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>问题:使用内置构造函数的方式和字面量的方式来创建对象差不多,都存在以下问题:</li>\n<li>\n<pre><code>  01 创建的对象无法复用,复用性差\n</code></pre>\n</li>\n<li>\n<pre><code>  02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高\n</code></pre>\n</li>\n</ul>\n<h3 id="%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">内置构造函数的方式来创建对象<a class="anchor" href="#%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>问题:使用内置构造函数的方式和字面量的方式来创建对象差不多,都存在以下问题:</li>\n<li>\n<pre><code>  01 创建的对象无法复用,复用性差\n</code></pre>\n</li>\n<li>\n<pre><code>  02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高\n</code></pre>\n</li>\n</ul>\n<h3 id="%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">简单工厂函数的方式来创建对象<a class="anchor" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>\n<p>简单工厂模式</p>\n<ul>\n<li>\n<p>工厂里面有一些产品的模板, 只需要, 给工厂提供原材料; 工厂按照固定的加工方式, 就可以返回给外界同一类型的产品</p>\n</li>\n<li>\n<p>问题:</p>\n<ul>\n<li>无法判定类型</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">自定义构造函数的方式来创建对象<a class="anchor" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">§</a></h3>\n<ul>\n<li>\n<p>01-自定义构造函数和简单工厂函数的对比</p>\n<ul>\n<li>\n<pre><code>① 函数的首字母大写(用于区别构造函数和普通函数)\n</code></pre>\n</li>\n<li>\n<pre><code>② 创建对象的过程是由new关键字实现\n</code></pre>\n</li>\n<li>\n<pre><code>③ 在构造函数内部会自动的创建新对象,并赋值给this指针\n</code></pre>\n</li>\n<li>\n<pre><code>④ 自动返回创建出来的对象\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>02-构造函数的执行过程:</p>\n<ul>\n<li>\n<pre><code>① 使用new关键字创建对象\n</code></pre>\n<ul>\n<li>外界</li>\n</ul>\n</li>\n<li>\n<pre><code>② 把新创建出来的对象赋值给this\n</code></pre>\n</li>\n<li>\n<pre><code>③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法\n</code></pre>\n</li>\n<li>\n<pre><code>④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>03-构造函数的返回值说明:</p>\n<ul>\n<li>\n<pre><code>01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象\n</code></pre>\n</li>\n<li>\n<pre><code>02 如果在构造函数中显示的return,则依照具体的情况处理\n</code></pre>\n<ul>\n<li>\n<pre><code>   [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象\n</code></pre>\n</li>\n<li>\n<pre><code>   [02] return 的是null或基本数据类型值,则返回新创建的对象\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>总结</p>\n<ul>\n<li>类型匹配才接受-&gt; 对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="16-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">16-对象的创建-简单使用<a class="anchor" href="#16-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">§</a></h2>\n<h3 id="%E5%AF%B9%E8%B1%A1%E5%9C%A8js%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0">对象在js中的体现<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8js%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0">§</a></h3>\n<ul>\n<li>键-值对的集合(key-value)</li>\n<li>属性:在对象内部声明的变量</li>\n<li>方法:在对象内部赋值在属性上的函数</li>\n</ul>\n<h3 id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">对象的创建<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">§</a></h3>\n<ul>\n<li>\n<pre><code>01 字面量\n</code></pre>\n<ul>\n<li>var person = {name:&quot;sz&quot;, age: 18, run: function () {alert(\'跑\');}};</li>\n</ul>\n</li>\n<li>\n<pre><code>02 使用内置构造函数来创建\n</code></pre>\n<ul>\n<li>var obj = new Object();</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C">对象的操作<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C">§</a></h3>\n<ul>\n<li>\n<pre><code>js对象支持动态特性:增加属性(方法) | 删除属性(方法) |修改属性(方法) |查询\n</code></pre>\n</li>\n<li>\n<p>操作对象的属性和方法可以使用两套方式:</p>\n<ul>\n<li>\n<pre><code>01 点语法\n</code></pre>\n</li>\n<li>\n<pre><code>02 中括号[]\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5">操作实践<a class="anchor" href="#%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5">§</a></h3>\n<ul>\n<li>\n<p>创建对象</p>\n</li>\n<li>\n<p>添加属性</p>\n<ul>\n<li>\n<p><a href="http://obj.name">obj.name</a> = \'sz\';</p>\n</li>\n<li>\n<p>系统会自动识别, 如果没有name属性, 则动态添加</p>\n<ul>\n<li>如果有, 则修改</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>查询</p>\n<ul>\n<li>\n<p>一般查询</p>\n<ul>\n<li>console.log(<a href="http://obj.name">obj.name</a>);</li>\n<li>console.log(obj[\'name\']);</li>\n</ul>\n</li>\n<li>\n<p>遍历查询</p>\n<ul>\n<li>\n<p>in 关键字</p>\n<ul>\n<li>\n<ol>\n<li>可以判断对象中是否包含某个属性</li>\n</ol>\n<ul>\n<li>pro in obj</li>\n</ul>\n</li>\n<li>\n<ol start="2">\n<li>可以遍历对象键值对</li>\n</ol>\n<ul>\n<li>for (var key in obj)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>注意</p>\n<ul>\n<li>\n<p>属性的访问形式</p>\n<ul>\n<li>[]</li>\n<li>不能用.</li>\n</ul>\n</li>\n<li>\n<p>in 在数组中的使用</p>\n<ul>\n<li>\n<ol>\n<li>可以判断对象中是否包含某个属性</li>\n</ol>\n<ul>\n<li>pro in obj</li>\n</ul>\n</li>\n<li>\n<ol start="2">\n<li>可以遍历对象键值对</li>\n</ol>\n<ul>\n<li>for (key in arr)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>修改属性</p>\n<ul>\n<li>\n<p><a href="http://obj.name">obj.name</a> = \'sz\';</p>\n</li>\n<li>\n<p>和添加属性的操作完全一样</p>\n</li>\n<li>\n<p>系统会自动识别, 如果没有name属性, 则动态添加</p>\n<ul>\n<li>如果有, 则修改</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>删除</p>\n<ul>\n<li>\n<p>delete关键字</p>\n<ul>\n<li>\n<pre><code>(1) 删除对象中的属性\n</code></pre>\n</li>\n<li>\n<pre><code>(2) 删除没有使用var关键字声明的全局变量\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>注意:</p>\n<ul>\n<li>\n<pre><code>    (1)返回值 布尔类型的值(我们可以通过该值来判断是否删除成功)\n</code></pre>\n</li>\n<li>\n<pre><code>    (2)使用var关键字声明的变量无法被删除\n</code></pre>\n<ul>\n<li>省略var关键字声明的变量, 相当于动态的给window增加一个属性</li>\n<li>window.xxxx = 100;</li>\n<li>这种方式,可以手动删除</li>\n</ul>\n</li>\n<li>\n<pre><code>    (3)删除对象中不存在的属性没有任何变化,但是返回值为true\n</code></pre>\n</li>\n<li>\n<pre><code>    (4)不能删除window下面的全局变量(使用var声明),但是可以删除直接定义在window上面的属性\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%8F%E6%A1%88%E4%BE%8B">17-面向对象小案例<a class="anchor" href="#17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%8F%E6%A1%88%E4%BE%8B">§</a></h2>\n<h3 id="%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97">计算器加减乘除运算<a class="anchor" href="#%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97">§</a></h3>\n<h3 id="%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">面向过程<a class="anchor" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B">§</a></h3>\n<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象<a class="anchor" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">§</a></h3>\n<h3 id="%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">链式调用<a class="anchor" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">§</a></h3>'
        } }),
    'toc': React.createElement("nav", { key: "0", className: "toc" },
        React.createElement("ol", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#javascript%E7%9A%84%E7%BB%84%E6%88%90" }, "JavaScript\u7684\u7EC4\u6210")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" }, "\u6570\u636E\u7C7B\u578B"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%9F%BA%E6%9C%AC%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" }, "\u57FA\u672C(\u7B80\u5355)\u6570\u636E\u7C7B\u578B")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%A4%E6%96%AD" }, "\u7C7B\u578B\u83B7\u53D6\u548C\u5224\u65AD"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E8%8E%B7%E5%8F%96%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" }, "\u83B7\u53D6\u5224\u65AD\u6570\u636E\u7C7B\u578B")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E8%A1%A5%E5%85%85" }, "\u8865\u5145")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E5%92%8C%E5%92%8C%E8%AF%B4%E6%98%8E" }, "=\u548C==\u548C===\u8BF4\u660E"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#" }, "=")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#-1" }, "==")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#-2" }, "===")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" }, "\u7C7B\u578B\u8F6C\u6362"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%A4%8D%E6%9D%82%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" }, "\u590D\u6742(\u590D\u5408)\u6570\u636E\u7C7B\u578B")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB" }, "\u57FA\u672C\u7C7B\u578B\u548C\u590D\u6742\u7C7B\u578B\u533A\u522B"),
                        React.createElement("ol", null)),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#dom" }, "DOM")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#bom" }, "BOM")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#-3" })))),
            React.createElement("li", null,
                React.createElement("a", { href: "#05-ecmascript-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6" }, "05-ECMAScript-\u5173\u7CFB\u8FD0\u7B97\u7B26"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E6%9E%9C%E6%98%AF%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B" }, "\u5173\u7CFB\u8FD0\u7B97\u7B26(\u7ED3\u679C\u662F\u5E03\u5C14\u7C7B\u578B)")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%A4%A7%E4%BA%8E" }, `大于(>)`)),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%B0%8F%E4%BA%8E" }, `小于(<)`)),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%B0%8F%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E" }, `小于等于(<=) 小于或者是等于`)),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E-%E5%A4%A7%E4%BA%8E%E6%88%96%E8%80%85%E6%98%AF%E7%AD%89%E4%BA%8E" }, `大于等于(>=) 大于或者是等于`)),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E4%B8%8D%E7%AD%89%E4%BA%8E" }, "\u4E0D\u7B49\u4E8E(!=)")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%B3%A8%E6%84%8F" }, "\u6CE8\u610F:")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#06-ecmascript-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6" }, "06-ECMAScript-\u903B\u8F91\u8FD0\u7B97\u7B26"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#01-%E9%80%BB%E8%BE%91%E9%9D%9E" }, "01 \u903B\u8F91\u975E")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#02-%E9%80%BB%E8%BE%91%E4%B8%8E" }, "02 \u903B\u8F91\u4E0E")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#03-%E9%80%BB%E8%BE%91%E6%88%96" }, "03 \u903B\u8F91\u6216")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%B3%A8%E6%84%8F-1" }, "\u6CE8\u610F:")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#07-ecmascript-%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF" }, "07-ECMAScript-\u5206\u652F\u548C\u5FAA\u73AF"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84" }, "\u6761\u4EF6\u7ED3\u6784")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84" }, "\u5FAA\u73AF\u7ED3\u6784")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#08-ecmascript-%E5%87%BD%E6%95%B0" }, "08-ECMAScript-\u51FD\u6570"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9B%E5%BB%BA" }, "1. \u51FD\u6570\u7684\u51E0\u79CD\u521B\u5EFA?")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#2-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7" }, "2. \u51FD\u6570\u4F7F\u7528\u6280\u5DE7")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8F%AB%E6%B3%95" }, "3. \u51FD\u6570\u7684\u51E0\u79CD\u53EB\u6CD5?")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#09-ecmascript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98" }, "09-ECMAScript-\u4F5C\u7528\u57DF\u95EE\u9898"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%A6%82%E5%BF%B5%E6%9F%90%E4%B8%AA%E5%8F%98%E9%87%8F%E6%9C%89%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%8C%83%E5%9B%B4" }, "\u6982\u5FF5\uFF1A\u67D0\u4E2A\u53D8\u91CF\u6709\uFF08\u8D77\uFF09\u4F5C\u7528\u7684\u8303\u56F4")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#js%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F" }, "js\u4E2D\u7684\u4F5C\u7528\u57DF")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE" }, "\u4F5C\u7528\u57DF\u94FE")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E5%8E%9F%E5%88%99" }, "\u53D8\u91CF\u67E5\u627E\u539F\u5219")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#10-ecmascript-%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87" }, "10-ECMAScript-\u53D8\u91CF\u548C\u51FD\u6570\u63D0\u5347"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#js%E7%9A%84%E6%89%A7%E8%A1%8C" }, "js\u7684\u6267\u884C\uFF1A")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E8%A7%84%E5%88%99" }, "\u89C4\u5219")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%B5%8B%E8%AF%95" }, "\u6D4B\u8BD5")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#11-ecmascript-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" }, "11-ECMAScript-\u5F02\u5E38\u5904\u7406"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%9C%BA%E6%99%AF" }, "\u573A\u666F")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E4%BD%BF%E7%94%A8" }, "\u4F7F\u7528")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#12-dom-%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5" }, "12-DOM-\u64CD\u4F5C(\u589E\u5220\u6539\u67E5)"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%A2%9E%E5%8A%A0" }, "\u589E\u52A0")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%88%A0%E9%99%A4" }, "\u5220\u9664")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E4%BF%AE%E6%94%B9" }, "\u4FEE\u6539")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%9F%A5%E8%AF%A2" }, "\u67E5\u8BE2")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#13-bom-%E6%93%8D%E4%BD%9C" }, "13-BOM-\u64CD\u4F5C"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B" }, "\u6D4F\u89C8\u5668\u5BF9\u8C61\u6A21\u578B")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E4%BD%9C%E7%94%A8" }, "\u4F5C\u7528")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD" }, "\u5177\u4F53\u529F\u80FD")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E9%87%8D%E8%A6%81%E5%AF%B9%E8%B1%A1" }, "\u91CD\u8981\u5BF9\u8C61")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#14-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" }, "14-\u9762\u5411\u5BF9\u8C61-\u76F8\u5173\u6982\u5FF5"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#01-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1" }, "01-\u4EC0\u4E48\u662F\u5BF9\u8C61?")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#02-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B" }, "02-\u9762\u5411\u5BF9\u8C61-\u9762\u5411\u8FC7\u7A0B")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F" }, "15-\u9762\u5411\u5BF9\u8C61-\u521B\u5EFA\u5BF9\u8C61\u7684\u65B9\u5F0F"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1" }, "\u5B57\u9762\u91CF\u7684\u65B9\u5F0F\u521B\u5EFA\u5BF9\u8C61")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1" }, "\u5185\u7F6E\u6784\u9020\u51FD\u6570\u7684\u65B9\u5F0F\u6765\u521B\u5EFA\u5BF9\u8C61")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1" }, "\u7B80\u5355\u5DE5\u5382\u51FD\u6570\u7684\u65B9\u5F0F\u6765\u521B\u5EFA\u5BF9\u8C61")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1" }, "\u81EA\u5B9A\u4E49\u6784\u9020\u51FD\u6570\u7684\u65B9\u5F0F\u6765\u521B\u5EFA\u5BF9\u8C61")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#16-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8" }, "16-\u5BF9\u8C61\u7684\u521B\u5EFA-\u7B80\u5355\u4F7F\u7528"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%AF%B9%E8%B1%A1%E5%9C%A8js%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0" }, "\u5BF9\u8C61\u5728js\u4E2D\u7684\u4F53\u73B0")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA" }, "\u5BF9\u8C61\u7684\u521B\u5EFA")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C" }, "\u5BF9\u8C61\u7684\u64CD\u4F5C")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5" }, "\u64CD\u4F5C\u5B9E\u8DF5")))),
            React.createElement("li", null,
                React.createElement("a", { href: "#17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%8F%E6%A1%88%E4%BE%8B" }, "17-\u9762\u5411\u5BF9\u8C61\u5C0F\u6848\u4F8B"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97" }, "\u8BA1\u7B97\u5668\u52A0\u51CF\u4E58\u9664\u8FD0\u7B97")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B" }, "\u9762\u5411\u8FC7\u7A0B")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" }, "\u9762\u5411\u5BF9\u8C61")),
                    React.createElement("li", null,
                        React.createElement("a", { href: "#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" }, "\u94FE\u5F0F\u8C03\u7528")))))),
    'author': "dingtt",
    'contributors': [
        "dingtt"
    ],
    'date': "2021-05-02T08:22:31.000Z",
    'updated': null,
    'excerpt': "程序 = 算法 + 数据结构 // 记录到wt第5章 JavaScript的组成 - 词法 - 直接量，关键字，运算符，标识符，保留字，操作符 - 语法语义 - 表达式，语句，函数，对象，模块 数据类型 基本(简单)数据类型 - null - null是基本类型中...",
    'cover': undefined,
    'sidebar': [
        {
            "text": "Hello world",
            "link": "index.html",
            "pagePath": "README.md"
        },
        {
            "link": "WebAPI/README.md",
            "children": [],
            "text": "WebAPI/README.md"
        },
        {
            "link": "HTTP/index.html",
            "children": [
                {
                    "text": "浏览器",
                    "link": "HTTP/browser.html",
                    "pagePath": "HTTP/browser.md"
                },
                {
                    "text": "HTTP协议请求方法和状态码",
                    "link": "HTTP/HTTP.html",
                    "pagePath": "HTTP/HTTP.md"
                },
                {
                    "text": "网络硬件",
                    "link": "HTTP/internet-hardware.html",
                    "pagePath": "HTTP/internet-hardware.md"
                }
            ],
            "pagePath": "HTTP/README.md",
            "text": "HTTP协议与浏览器"
        },
        {
            "link": "js/todo.md",
            "children": [
                {
                    "text": "JavaScript基础",
                    "link": "js/basics.html",
                    "pagePath": "js/basics.md"
                },
                {
                    "text": "基础",
                    "link": "js/Object.html",
                    "pagePath": "js/Object.md"
                },
                {
                    "text": "执行上下文",
                    "link": "js/context.html",
                    "pagePath": "js/context.md"
                },
                {
                    "text": "闭包和面向对象",
                    "link": "js/closure.html",
                    "pagePath": "js/closure.md"
                },
                {
                    "text": "正则",
                    "link": "js/regex.html",
                    "pagePath": "js/regex.md"
                },
                {
                    "text": "算法",
                    "link": "js/algo.html",
                    "pagePath": "js/algo.md"
                },
                {
                    "text": "JS设计模式",
                    "link": "js/design-patterns.html",
                    "pagePath": "js/design-patterns.md"
                }
            ],
            "text": "js/todo.md"
        },
        {
            "link": "TS/index.html",
            "children": [
                {
                    "text": "TS基础",
                    "link": "TS/basics.html",
                    "pagePath": "TS/basics.md"
                },
                {
                    "text": "TS枚举 类型 接口 泛型",
                    "link": "TS/enum.html",
                    "pagePath": "TS/enum.md"
                }
            ],
            "pagePath": "TS/README.md",
            "text": "TS"
        },
        {
            "link": "vue/index.html",
            "children": [
                {
                    "text": "Vue开发技巧",
                    "link": "vue/vue-skills.html",
                    "pagePath": "vue/vue-skills.md"
                },
                {
                    "text": "Vue组件通信",
                    "link": "vue/vue-communication.html",
                    "pagePath": "vue/vue-communication.md"
                },
                {
                    "text": "Vue路由",
                    "link": "vue/vue-router/vue-router.html",
                    "pagePath": "vue/vue-router/vue-router.md"
                }
            ],
            "pagePath": "vue/README.md",
            "text": "Vue"
        },
        {
            "text": "React的生命周期",
            "link": "react/lifecycle.html",
            "pagePath": "react/lifecycle.md"
        },
        {
            "link": "webpack/index.html",
            "children": [
                {
                    "text": "webpack的使用",
                    "link": "webpack/webpack-use.html",
                    "pagePath": "webpack/webpack-use.md"
                },
                {
                    "text": "Webpack打包原理解析",
                    "link": "webpack/webpack-principle.html",
                    "pagePath": "webpack/webpack-principle.md"
                },
                {
                    "text": "生产环境配置",
                    "link": "webpack/webpack-dev-config.html",
                    "pagePath": "webpack/webpack-dev-config.md"
                },
                {
                    "text": "实现自己的loader",
                    "link": "webpack/webpack-custom-loader.html",
                    "pagePath": "webpack/webpack-custom-loader.md"
                },
                {
                    "text": "实现自己的plugin",
                    "link": "webpack/webpack-custom-plugin.html",
                    "pagePath": "webpack/webpack-custom-plugin.md"
                },
                {
                    "text": "webpack代码分片",
                    "link": "webpack/webpack-split-chunks.html",
                    "pagePath": "webpack/webpack-split-chunks.md"
                },
                {
                    "text": "webpack-dev-server 与 HMR",
                    "link": "webpack/webpack-dev-server-hmr.html",
                    "pagePath": "webpack/webpack-dev-server-hmr.md"
                }
            ],
            "pagePath": "webpack/README.md",
            "text": "Webpack"
        },
        {
            "text": "前端监控简介",
            "link": "web-monitor/web-monitor.html",
            "pagePath": "web-monitor/web-monitor.md"
        },
        {
            "text": "Git使用",
            "link": "git/git.html",
            "pagePath": "git/git.md"
        }
    ]
};
