# webpack代码分片

## 通过入口拆分代码

webpack中每个入口都将生成一份对应的资源文件

```
// webpack.config.js
entry: {
  app: './main.js',
  lib: ['liba', 'libb']
}
```

适合将对象挂载到window上的库

## CommonsChunkPlugin

webpack4之前，主要用于多入口之间的公共模块，也可用于提取单页面的模块

```
new webpack.optimize.CommonChunkPlugin({
  name: 'common', // 用于指定公共chunk的名字
  filename: 'common.js', // 提取后的资源名字
  chunks:['a', 'b'],  // 提取范围，对应entry里的chunk
  minChunks:3, // 数字 被3以上入口引用才提取，不影响entry中单独配置的提取数组  还可以设置Infinity 和 函数
})
// 需要在页面上 在其他js之前引入common.js
```

```
// 提取单页面 
entry: {
  app: './main.js',
  vendor: ['react'] // 提取第三方类库及业务中不常更新的模块
}
// 插件配置同上
```

minChunks为函数，每个模块都会经该函数处理，返回值为true时进行提取

```
minChunks: function(module, count) {
  // module.context 模块目录路径
  // module.sourece 模块目录的完整路径
  // count 模块被引用的次数
}
```

提取webpack的运行时，防止影响公共模块的hash，mainfest的CommonsChunkPlugin必须出现在最后，在页面中引入必须在最前

```
new webpack.optimize.CommonChunkPlugin({
  name:'mainfest'
})
```

**不足**

- 提取特定入口的特定模块

- 只能提取一个vendor，想提取多个需要配置多次，


- mainfest会使浏览器多加载一个资源 


- 异步情况下会有问题

webpack为每个面模块指定的id是按数字递增的，当有新的模块产生时会导致其他的模块id变化，可能影响vendor的hash。

解决办法，使用 HashedModuleIds-Plugin 为每个模块按照其所在的路径生成hash id

```
new HashedModuleIds-Plugin()
// ... CommonsChunksPlugin
```




### optimization.SplitChunks

可以设置提取的条件：提取的模式，提取模块的体积

```
optimization: {
  splitChunks: {
    chunks: 'all', // 对所有chunks生效，如果不配置，默认只对异步资源生效 async（默认） initial all
    minSize: {
      javascript:30000,
      style:50000,
    },
    maxSize:0,
    minChunks:1,
    maxAsyncRequests:5, // 异步加载并行请求并行请求最大资源数
    maxInitialReauests:3, // 首次加载
    automaticNameDelimiter:'~', // 分隔符
    name:true, // 根据cacheGroups和作用范围自动生成chunk命名
    cacheGroups: {
      vendors: { // 用于提取所有 node_modules 中符合条件的模块
        test: /[\\/]node_modules[\\/]/,
        priority: -10
      },
      default: { // default则作用于被多次引用的模块
        minChunks:2,
        priority: -20,
        resuseExistingChunk: true
      }
    }
  }
}
```

- 提取后的chunks可被共享，或者来自node_modules

- 提取后的js chunk大于30kB，CSS chunk大于50kB

- 按需加载时，并行请求的资源最大值小于等于5

- 首次加载时（不计算异步资源），并行请求的资源最大值小于等于3

## 异步加载

正常加载  `import  bar from './bar.js'`    异步加载 `import('./bar.js').then()`

配置异步加载的chunk名

```
output: {
  chunkFileName: '[name].js'
}
import(/* webpackChunkName: [name]*/'./bar.js').then()
```

### bundle体积监控和分析

Vs code 插件 import Cost  可以实时显示引入模块的大小和压缩后的大小

### webpack-bundle-analyzer

```
scripts: {
  "test:size": "bundlesize"
}
```

