# webpack代码分片

## 通过入口拆分代码

webpack中每个入口都将生成一份对应的资源文件

```
// webpack.config.js
entry: {
  app: './main.js',
  lib: ['liba', 'libb']
}
```

适合将对象挂载到window上的库

## CommonsChunkPlugin

webpack4之前，主要用于多入口之间的公共模块，也可用于提取单页面的模块

```
new webpack.optimize.CommonChunkPlugin({
  name: 'common', // 用于指定公共chunk的名字
  filename: 'common.js', // 提取后的资源名字
  chunks:['a', 'b'],  // 提取范围，对应entry里的chunk
  minChunks:3, // 数字 被3以上入口引用才提取，不影响entry中单独配置的提取数组  还可以设置Infinity 和 函数
})
// 需要在页面上 在其他js之前引入common.js
```

```
// 提取单页面 
entry: {
  app: './main.js',
  vendor: ['react'] // 提取第三方类库及业务中不常更新的模块
}
// 插件配置同上
```

minChunks为函数，每个模块都会经该函数处理，返回值为true时进行提取

```
minChunks: function(module, count) {
  // module.context 模块目录路径
  // module.sourece 模块目录的完整路径
  // count 模块被引用的次数
}
```

提取webpack的运行时，防止影响公共模块的hash，mainfest的CommonsChunkPlugin必须出现在最后，在页面中引入必须在最前

```
new webpack.optimize.CommonChunkPlugin({
  name:'mainfest'
})
```

**不足**

- 提取特定入口的特定模块

- 只能提取一个vendor，想提取多个需要配置多次，


- mainfest会使浏览器多加载一个资源 


- 异步情况下会有问题

webpack为每个面模块指定的id是按数字递增的，当有新的模块产生时会导致其他的模块id变化，可能影响vendor的hash。

解决办法，使用 HashedModuleIds-Plugin 为每个模块按照其所在的路径生成hash id

```
new HashedModuleIds-Plugin()
// ... CommonsChunksPlugin
```




### optimization.SplitChunks 代码分割

可以设置提取的条件：提取的模式，提取模块的体积

基础配置

```
optimization:{    //帮我们自动做代码分割    
  splitChunks:{        
    chunks:"all",//默认是支持异步，我们使用all    
   } 
}
```

使用

```javascript
//webpack.config.js 
entry: {
  lodash: "./lodash.js",
  index: "./index.js"
}
//指定打包后的资源位置  
output: {
  path: path.resolve(__dirname, "./build"),
  filename: "[name].js"
}
```



```javascript
// 全部配置
optimization: {
  splitChunks: {
    chunks: 'all', // 对所有chunks生效，如果不配置，默认只对异步资源生效 async（默认） initial all
    minSize: {
      javascript:30000, // 当模块大于30kb
      style:50000,
    },
    maxSize:0, // 对模块进行二次分割时使用，不推荐
    minChunks:1, // 打包成chunk最少有几个引用
    maxAsyncRequests:5, // 异步加载并行请求并行请求最大资源数
    maxInitialReauests:3, // 首次加载 入口文件并行最大资源数
    automaticNameDelimiter:'~', // 分隔符
    name:true, // 根据cacheGroups和作用范围自动生成chunk命名
    cacheGroups: {
      vendors: { // 用于提取所有 node_modules 中符合条件的模块
        test: /[\\/]node_modules[\\/]/,
        priority: -10 // 数字越大 优先级越高
      },
      default: { // default则作用于被多次引用的模块
        minChunks:2,
        priority: -20,
        resuseExistingChunk: true
      }
    }
  }
}
```

- 提取后的chunks可被共享，或者来自node_modules

- 提取后的js chunk大于30kB，CSS chunk大于50kB

- 按需加载时，并行请求的资源最大值小于等于5

- 首次加载时（不计算异步资源），并行请求的资源最大值小于等于3

## 异步加载

正常加载  `import  bar from './bar.js'`    异步加载 `import('./bar.js').then()`

配置异步加载的chunk名

```
output: {
  chunkFileName: '[name].js'
}
import(/* webpackChunkName: [name]*/'./bar.js').then()
```

### development/production

```javascript
// 命令行配置
const merge = require("webpack-merge") 
const commonConfig =  require("./webpack.common.js") 
const devConfig = {}
 
module.exports = merge(commonConfig,devConfig)
 
//package.js 
"scripts":{    
    "dev":"webpack-dev-server --config ./build/webpack.dev.js",    
    "build":"webpack --config ./build/webpack.prod.js" 
}
```

```javascript
//外部传入的全局变量 
module.exports = (env) => {
  if (env && env.production) {
    return merge(commonConfig, prodConfig)
  } else {
    return merge(commonConfig, devConfig)
  }
}

//外部传入变量 
scripts:" --env.production"

```



### bundle体积监控和分析

Vs code 插件 import Cost  可以实时显示引入模块的大小和压缩后的大小

### 打包分析webpack-bundle-analyzer

```
scripts: {
  "test:size": "bundlesize"
}
```

### 通过控制台看看代码利用率

### 把js里import的异步js文件抽离处理

```
 npm install --save-dev @babel/plugin-syntax-dynamic-import 
```

### tree-shaking

把没有引用的代码去掉

```
//webpack.config.js
optimization: {    
  usedExports: true  
}
//package.json "sideEffects":false  正常对所有模块进行tree shaking  或者 "sideEffects"['*.css','@babel/polyfill']

```

