# 前端异常监控系统实践

在看一些前端监控相关的文章时，经常看到评论中提到业界成熟的方案，没有必要自己造轮子。我这里做前端监控相关的研究，主要就是为了熟悉整个流程，并不是为了要替代轮子。本文算是一个总结，记录一些关键技术点，以供读者参考。内容涵盖从异常采集、到上报、存储方案和方法。

首先介绍系统的概况，整个采集系统分为采集SDK，展示平台、后端服务三个，采集SDK使用Typescript开发，使用Rollup打包；展示平台使用vue+ ，后端使用EGG框架快速开发。

## 数据采集SDK

数据采集部分，主要采集了异常信息，坏境信息，性能信息。

### 异常采集

#### 前端JS错误

JS的错误信息采集，有`window.onerror()` 和`window.addEventLisenter('error',function(){})`两种方法，

`window.onerror()`只能订阅一个，无法获取到资源加载失败的情况，

使用 window.addEventLisenter（'error'）可以捕获资源加载失败的情况。IE8之前不支持

window.onError 是一个标准的错误捕获接口，它可以拿到对应的这种 JS 错误；最大的好处就是可以同步任务还是异步任务都可捕获， onerror还有一个问题大家要注意 如果返回返回true 就不会被上抛了

window.addEventLisenter（'error'）也可以捕获到错误，但是它拿到的 JS 报错堆栈往往是不完整的。window.onError 无法获取到资源加载失败的一个情况，必须使用 window.addEventLisenter（'error'）来捕获资源加载失败的情况。

```javascript
window.onerror = fucntion(message, source, lineno, colno,error){ ... }
```

```javascript
window.addEventListener('error', function(errorEvent) {
    const { message, filename, lineno, colno, error } = errorEvent
    ...
}, true)
```



`try catch`

| 属性            | 含义              | 说明                                               |
| --------------- | ----------------- | -------------------------------------------------- |
| message         | 错误信息          | 错误描述                                           |
| filename/source | 发生错误的脚本URL | `ErrorEvent`中是`filename`,在`onError`中是`source` |
| lineno          | 错误行            |                                                    |
| colno           | 发生错误的脚本URL |                                                    |
| error           | Error 对象        | `error.message error.stack` 是很重要的信息         |

js中常见的几种Error类型

- SyntaxError 语法错误

- Uncaught ReferenceError 引用错误

- RangeError 范围错误

- TypeError 类型错误

* URIError URL错误

* EvalError eval()函数执行错误

#### 资源加载错误

资源如图片等加载失败，如上段所说，需要使用 window.addEventLisenter('error')，获取到 `errorEvent`。对于普通JS错误，`errorEvent.target`指向window ，而对于资源加载错误，则指向相应的标签，可以通过taget的nodeName或tagName进行判断类型，筛选或排除指定的资源类型。

**optional chaining**

```javascript
obj?.prop
obj?.[expr] 
func?.(...args) 
```

当`?.`前面的变量为`null`或是`undefined`时，直接返回`undefined`

Script.Error  语法错误SyntaxError ， *贝贝在这里return了此类报错，在另外的方法中单独执行*

#### Promise异常捕获

onError和错误事件侦听，都无法获取`new Promise()` 里的报错，.catch()可以捕获到异常，但是需要每个Primise都添加.catch，但是监控逻辑不应该侵入业务代码的，可以将unhandledrejection抛出的错误再次抛出，就可以在addEventListener中捕获。

可以考虑将unhandledrejection事件捕获错误抛出交由错误事件统一处理 ）（案例：打印e的内容，错误信息挂在reason上，包含message,stack）

```javascript
window.addEventListener("unhandledrejection", e => {
  throw e.reason
})
```

#### async/await异常捕获

async异常可以被上层try catch捕获，如果没有，就只能通过unhandledrejection事件捕获了。

#### 跨域JS错误

script 标签引入的跨域脚本，如果出现异常，window 下的 error 事件都只能得到 `Script error`，没有详细的错误信息，这里有两种解决方案。

1. 使用 crossOrigin 

   给`<script>`标签添加crossorigin属性， 并在服务器端设置 `Access-Control-Allow-Origins`响应头，允许脚本被跨域访问，
    就可以获取更详细的日志信息。

   | crossorigin属性的取值 |                                                              |      |
   | --------------------- | ------------------------------------------------------------ | ---- |
   | anonymous             | 依赖CROS，不带cookie，当AS设置不等于origin或不是*时，js不加载 |      |
   | use-credentials       | 需要`Access-Control-Allow-Credentials` 返回 true，此时浏览器`Access-Control-Allow-Origins:domian.com`必须设置具体域名，不支持通配符*，AC不等于origin时js不再加载 |      |

    如果给 <script> 标签添加了`crossorigin`属性，但是服务器端没有设置`Access-Control-Allow-Origins`，则会报跨域错误。

2. `try...catch`

   该方案的弊端是需要包裹，只适合于被监控应用使用自定义上报方法主动上报。并且在 `try` 中发生的错误，浏览器不会把错误打在 `console` 里，也不会触发 `error` 事件，需要在 `catch` 里，把错误打在 `console.error` 里面，并手动包装 `ErrorEvent`，丢给 `window` 下的 `error` 事件捕获。


console里触发的异常

浏览器拦截的数据

#### 数据接口异常

数据接口常见异常，一是由于接口不可用导致前端出现问题，二数据字段导致缺失导致出现的JS错误，第二种错误往往可以在`error`中捕获的到，而对于数据接口的状态，基于`XMLHttpRequest`发起的数据请求，可以使用面向切片编程，劫持原型链上的方法，获取`xhr`实例，绑定事件监听。

```js
const orignalEvents = [
    'abort',
    'error',
    'load',
    'timeout',
    'onreadystatechange',
  ]
const method = 'open'
const originalXhrProto = window.XMLHttpRequest.prototype
const original = originalXhrProto[method]
 originalXhrProto[method] = function (...args) {
    // 获取xhr实例  绑定事件
    const xhr = this
    orignalEvents.forEach((eType) => {
      xhr.addEventListener(eType, function (e) {
        // ...
      })
    })
    original.apply(this, args)
  }
```

#### Vue异常

对于Vue中发生的异常，需要利用vue提供的handleError，一旦Vue发生异常都会调用这个方法。

```js
Vue.config.errorHandler = function (err, vm, info) {
  console.log('errorHandle:', err)
}
```

同样我们使用面向切片编程的方式，对`errorHandler`进行劫持。

```js
export function listenVueError(_Vue): void {
  if (!_Vue || !_Vue.config) {
    return
  }
  const oldErrorHandler = _Vue.config.errorHandler
  _Vue.config.errorHandler = function (err, vm, info) {
    console.log(err, vm, info)
    // errorHandler方法自己又报错了生产环境下会使用 console.error 在控制台中输出
    // 继续抛出到控制台
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(err)
    }
    eventEmitter.emit(LISTEN_EVENTS.VUE,err)
    if (typeof oldErrorHandler === 'function') {
      oldErrorHandler.call(this, err, vm, info)
    }
  }
}
```

另外还有涉及小程序、`React`、`ReactNative` 、App容器中的一些异常捕获方案，需要在被监控端添加少量代码，使用自定义上报，无法做到零入侵，未在SDK中涉及，不再详细列出。

```javascript
try {
    JSON.stringify(apiData)
} catch (error) {
    console.error(error)
    if (ErrorEvent) {
        window.dispatchEvent(new ErrorEvent('error', { error, message: error.message })) // 这里也会触发window.onerror
    } else {
        window.onerror && window.onerror(null, null, null, null, error)
    }
}
```

贝贝

![image.png](https://cdn.nlark.com/yuque/0/2020/png/146912/1587821458555-eec8bb77-c050-40fa-8d14-fa26625596ae.png)

仍不足，**不能捕获异步代码**的异常。比如 `setTimeout`、`promise`、事件等

防止Script Error总结

通过patch方式 2.客户端所有调用js方法需要做保护  3.客户端也需要添加缓存头

IOS中跨域的异步脚本报错信息在window.onError 中是捕获不到的（解决方案之呢个在异步端代码里手动抛出错误进行捕获）

通过native代码执行的脚本，是无法被捕获的。

| 异常类型           | 同步方法 | 异步方法 | 资源加载 | Promise | async/await |
| ------------------ | -------- | -------- | -------- | ------- | ----------- |
| try/catch          | √        |          |          |         | √           |
| onerror            | √        | √        |          |         |             |
| error事件监听      | √        | √        | √        |         |             |
| unhandledrejection |          |          |          | √       | √           |

### 性能采集

#### performance

性能采集，首先是收集`window.performance.timing`，以下是部分指标的计算。

```js
// 测试输出
function calculateTiming(perf) {
  log('perf', perf)
  log('重定向耗时', perf.redirectEnd - perf.redirectStart)
  log('DNS查询耗时', perf.domainLookupEnd - perf.domainLookupStart)
  log('TCP链接耗时', perf.connectEnd - perf.connectStart)
  log('HTTP请求耗时 ', perf.responseEnd - perf.responseStart)
  log('解析dom树耗时', perf.domComplete - perf.domInteractive)
  log('首包时间（~<白屏时间） ', perf.domLoading - perf.navigationStart)
  log(
    'domready可操作时间',
    perf.domContentLoadedEventEnd - perf.navigationStart
  )
  // 需在onload里调用时，perf.loadEventEnd 未结束时值为0
  log('onload总下载时间', perf.loadEventEnd - perf.navigationStart)
}
```

#### 其他指标

过`performance.getEntries()`，此方法返回 `PerformanceEntry` 对象数组，每个数组成员均是一个`PerformanceResourceTiming`对象。

```
// 取全部
const entries = window.performance.getEntries();
// 取特定
const entries = performance.getEntries({name: "entry_name", entryType: "mark"});
```

![image-20210307215254327](/Users/apsp/Library/Application Support/typora-user-images/image-20210307215254327.png)

**白屏时间(FP)**与**首屏时间(FCP)**

其中name为`first-paint`的对象，`startTime`和`duration`的值，即为白屏时间(FP)，`name`为`first-contentful-paint`，即为**首屏时间(FCP)** ，需要注意的是`PerformancePaintTiming`只支持chrome60、opera47以上版本，还有一些其他的Chrome 官方API指标，可以自行查阅资料。

##### 打点时间

另外通过`performance.mark()`可以自行记录打点时间，例如在`</head>`前自行埋点`performance.mark('first-paint-script’)`，然后在获取`name`属性为`first-paint-script`的`entry`，获取对应的时间，这一时间近似白屏时间。

SDK中可以约定一些常见的性能指标，被监控端选择合适的位置自行埋点，用于补充性能监控数据。

##### 起始时间

因为像腾讯的 Vas sonic，在webview打开的时候就去请求HTML，而不是WebVIew加载好之后再请求。

启动时间： performance.timing.navigationStart || query('_t') ,约定URL中存在 _t 时，作为页面统计起始点时间

#### 图片加载时间

MutationObserver侦听DOM变化，在5秒内到最后一个变化的稳定时间点，作为时间点得到时间点T1，再用ResoucereTiming得到T1时间内加载的所有的图片Img，判断是不是本站（需统计）图片，排除上报gif图片，得到图片资源加载完成时间T2。

`ResoucereTiming`的`entryType`值为`resource`，chrome浏览器中`initiatorType`为 `img`  ，firefox中`initiatorType` 为`other` 。

#### 首次加载或刷新

在收集性能的同时，记录页面是首次刷新还是加载，可利用给window.name属性赋值，在页面刷新时不会重置来判断

如果是单网页应用的首屏时间计算，更精准的时间计算，还需要根据业务需要自行打点记录。

### 坏境信息采集

环境信息主要通过采集UA信息，进行上报，后台通过计算，获取浏览器分布等信息。

```js
export function getEnv(): Ienv {
  if (typeof window === 'undefined') return
  const navigator = window.navigator
  const connection = navigator['connection']
  const envData = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    language: navigator.language,
    url: window.location.href,
    net: connection ? connection.effectiveType : null, // 网络类型
    screenW:window.screen.width,
    screenH:window.screen.height
  }
  return envData
}
```

地域分布首先通过打点服务器获取ip，再通过系统服务端，利用第三方IP解析服务，获取用户地域分布。

### 行为采集

#### 点击输入行为

使用addEventListener全局监听点击事件，将用户行为（click,input）和dom元素相关信息，存入行为栈，当错误发生将错误和行为一并上报。

```js
export function handleBehaviorEvent(
  e: Event | MouseEvent,
  type: LISTEN_EVENTS
): void {
  const target = Array.isArray(e) ? e[0].target : e.target
  //   todo Xpath  outerHTML  offsetX pageX
  const { tagName, className,id ,innerText } = target
  behaviorCache.directPush({
    type,
    data: {
      tagName,
      className,
      id,
      innerText:innerText.substr(0,10),
      xpath : xpath(target), // 可选
      name : target.name || target.src || target.href 
    },
  })
}
```

#### 发送请求行为（浏览器行为）

参考异常采集，数据异常一段中，收集请求相关数据。

#### 页面跳转（浏览器行为）

页面跳转通过监听`hashchange`和`history.pushState` 和`history.replaceState`实现。需要注意的是，带hash的页面加载，会同时触发popstate

```js
let oldURL =  window.location.href
/**
 * historychange
 * 带hash的页面加载会触发popstate
 * 带hash回车 不管开始有没有hash 会触发俩事件
 * chrome 火狐 浏览器前进，从无到有hash，同时触发hashchange，从有到无不触发
 * chrome 火狐 浏览器后退，从无hash到有不触发，从有到无，同时触发hashchange
 *
 * @export
 * @param {PopStateEvent} e
 * @param {LISTEN_EVENTS} type
 */
export function handleHistoryChange(
  e: PopStateEvent,
  type: LISTEN_EVENTS
): void {
  const oldHash = getHash(oldURL)
  const newURL = (e.target as Window).location.href
  const newHash = (e.target as Window).location.hash
  // 缓存旧url用于数据处理
  const tempOldURL = oldURL
  oldURL = newURL // 更新URL
  if (oldHash || newHash) {
    // 这种情况,交由hashchange处理
    return
  }
  behaviorCache.directPush({
    type,
    data: {
      oldURL:tempOldURL,
      newURL,
    },
  })
}

export function handleHashChange(
  e: HashChangeEvent,
  type: LISTEN_EVENTS
): void {
  const {oldURL, newURL } = e
  behaviorCache.directPush({
    type,
    data: {
      newURL,
      oldURL,
    },
  })
}
```



#### 控制台打印

可以通过改写console对象的info、warn、error 方法进行记录。

——————

#### 在线时长

问题：用户停留时间过长，数据失真，解决办法：去掉特别高的，算平均数；用中位数，设置置信区间，拍续较高的数据（政采）

来源分布

页面跳转 SPA/MPA页面跳转，APP/小程序页面的切换

spm结构

https://www.yuque.com/zaotalk/posts/zcllhg#7

模块/按钮 点击率

访问量

用户页面操作： 点击 滑动 复制等;

#### 政采云

在项目编译的时候，植入项目ID，挂载页面的head部分，进入页面的时候根据页面路径，自动生成页面ID，挂载在body上，最后在用户将进入页面和离开页面的时候，数据采集的SDK能自动拿到项目ID，页面ID,去定位一个唯一的页面，做到自动化的上报进入和离开的事件。

触发点击事件的DOM点，称之为坑位，坑位的外层包裹的DOM节点称之为区块。需要以代码侵入的方式，使用工具协助挂载。

事件拦截 url拼接各种id跳转

### 主动上报

业务前端只负责埋点，实行统一的采集方案。

## 日志上报

### 上报方式

日志上报采用new Image请求nginx服务器上1像素gif图片的方式，将日志数据转化为字符串格式，附在图片的src之后，这样便解决了上报跨域的问题。之所以使用1px的gif图片，是因为同为1px的图片，gif格式的数据量最小。

```js
export function imgLoadPromise(url: string): Promise<Event> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.onload = (res) => {
      resolve(res)
    }
    img.onerror = (err) => {
       reject(err) //  防止上报地址错误造成死循环
    }
    img.src = url
  })
}
```

#### 上报数据

##### 错误信息

| 属性名称        | 含义                  | 类型   |
| --------------- | --------------------- | ------ |
| message         | 错误信息              | String |
| filename/source | 异常的资源URL或文件名 | String |
| lineno          | 异常行号              | Number |
| colno           | 异常列号              | Number |
| error           | 错误对象              | Object |
| error.message   | 错误信息              | String |
| err.stack       | 错误信息              | String |

将错误信息和其他信息等，存入一个JSON对象。

```js
// 上传的数据  尽量简化字符
const logData = {
  appkey: '',
  vv: '', // 应用版本
  uuid: '', // 设备id
  uid: '', // 用户id
  sid: '', // session id
  ua: '', // userAgent
  url: '', // 页面url
  title: '', //  字符串超长优先省略该项
  type: '', // 日志类型  错误 性能 行为
  ext: {}, // 扩展参数
  bh: {}, // 行为数据
  env: {}, // 环境信息
  perf: {}, // 性能数据
  errType: '', // 宽范围的错误类型，可以使用数字标识，只区分 jsError resourceError httpErr
  error: {
    // js错误对应
    type: '', // js错误类型 ，如果堆栈中存在可以去掉
    msg: '',
    source: '',
    lineno: 0,
    colno: 0,
    stack: '',
    // 资源错误
    outerHTML: '<img src="test.jpg">', // target.outerHTML
    src: 'https://www.test.com/test.jpg', // target.src  currentSrc
    tagName: 'IMG', // target.nodeName tagName 'IMG'
    id: '', //  target.id
    className: '', // target.className
    name: 'jpg', //  target.name
    // "XPath": "/html/body/img[1]",
    //       "selector": "HTML > BODY:nth-child(2) > IMG:nth-child(2)",
    //       "status": 404,
    //       "statusText": "Not Found"
  }, // 错误数据
  time: '', // 上传时间，错误捕获时间
}
```

将JSON对象转换为paramsString

#### SDK配置

```js
export let defaultConfig: AppConfig = {
  // 基础数据
  version: '', // 所监控应用版本
  appkey: '', // 应用id，来自平台
  reportUrl: '', // 图片上报地址 1像素gif，可跨域，末尾不带&
  uuid: '', // 设备唯一id 默认自动生成
  uid: '', // 用户id
  sid: '', // session id
  ext: '', // 扩展参数，JSON.stringify()
  // 设置相关
  isTest: false, // 是否为测试数据，测试数据
  autoReport: true, // 是否开启自动上报，默认为true
  rate: 1, // 抽样率(0~1) 默认为1
  // delay: 0, // 延时上报 时间为毫秒
  // submit: null, // 自定义上报方式
  repeat: 20, // 同一错误上报次数
  error: true, // 是否上报js错误，默认为true
  // 配置错误监控详细信息，仅在开启js上报时有效
  errorConfig: {
    errorJS: true, // 大类 js运行错误
    errorResource: true, // 大类 资源加载错误
    // 以下细分 仅在资源加载错误为true时有效
    // errorScript: true, // js脚本加载错误
    // errorImage: true, // 图片加载错误
    // errorCSS: true, // 样式文件加载错误
    // errorAudio: true, // 音频加载错误
    // errorVideo: true, // 视频加载错误
    // 以上仅在资源加载错误为true时有效
    errorAjax: true, // 大类 ajax请求错误
    errorSocket: true, // socket 连接错误
    errorVue: true, // Vue运行报错
    errorTry: true, // try未catch报错
  },
  // 忽略某种错误
  ignore: {
    ignoreErrors: [], // 忽略某种错误，对照error stack，支持Regexp和Function
    ignoreUrls: [], // 忽略某页面url或文件url或接口报错，支持单条或数组
  },
  behavior: true, // 是否监控用户行为，默认为true, 可为json
  performance: true, // 是否监控页面性能，默认为true, 可配置为json
}
```

SDK初始化

```js
 var dm = new Monitor({
      version: '1.0.0', // 所监控应用版本
      appkey: '4749fb30-3562-11eb-bf47-5d73b473057a', // 应用id，来自平台
      reportUrl: 'http://118.190.***.***:8091/track.gif',
      isTest: true,
      uuid: '', // 设备唯一id 默认自动生成
      uid: localStorage.getItem('uid') ? localStorage.getItem('uid') : ('user_' + Date.now())
    }
  )
```



#### 性能优化

初始化内联SDK，加载主体SDK（两次重试），

预上报池，数据预处理，合并上报

##### 并发控制

上报尽量不影响业务主体请求，将上报信息推入上报队列，控制上传的并发。

##### requestIdleCallback

`requestIdleCallback`可以检测浏览器的空闲状态，可以在空闲时发送业务请求。

##### 上报信息丢失处理

浏览器关闭，没有发送的丢失，在windows里面发一个同步的XHR请求，移动端无效，移动端关闭页面需要联合客户端一起处理。上报失败存到indexDB，作为本地日志，等到用户下一次进入的时候，再一并上报，或者服务器下指令，主动上传日志。

##### 服务端

服务端直接返回204，提高速度。

##### 重复上报次数限制

利用错误信息的路径，行号等信息，排除同一种错误的不同特性信息，不同系统版本的差异信息，校验md5是否一样，同类型错误数量大于N条（可配置）不再上传。后续可只记录错误出现的次数，更新错误最后出现的时间。

##### 采样率

在初始化SDK时，设置采样率，在上传时按采样率`const randomIgnore = Math.random() >= (config.rate || 1)`采样入库。

##### navigator.sendBeacon()   

`navigator.sendBeacon()` 方法可用于通过HTTP将少量数据异步传输到Web服务器。sendBeacon 带FromData，优先级变高会影响业务

采集端 接入层 NGINX 处理层：Node  Kafka 离线任务   DB：mongoDB MySQL   管理端Admin

参考宋小菜  ES方案，kafka，kafka替代方案Redis/RabbitMQ

ES：获取数据 数据预处理 数据聚合

两种削峰机制：每分钟数据获取上线10000条，超过就采样入库



预处理

webviewSDKScriptError   提取有用信息，删除无用信息，

数据聚合 

优化存储空间，优化查询性能，从多个维度来做决，业务名，错误类型；错误信息，md5是否一样（排除同一种错误的不同特性信息，不同系统版本的差异信息），统一错误合并（记录最早的时间，最后的时间，次数

清洗过程监控 数据量和耗时，忽略的数据，每分钟拉取数据量

### 上报工程

#### nginx配置

修改nginx配置文件http块中的log_format为json格式。

```shell
 # 对日志格式化成json
    log_format json '{"@timestamp":"$time_iso8601",'
                    '"@version":1,'
                    '"host":"$server_addr",'
                    '"client":"$remote_addr",'
                    '"size":$body_bytes_sent,'
                    '"responsetime":$request_time,'
                    '"domain":"$host",'
                    '"url":"$uri",'
                    '"status":"$status"}';
```

日志中记录ip/time/referer/UA等。

#### 读取nginx日志入库

#### Filebeat

Filebeat是本地文件的日志数据采集器，可监控日志目录或特定日志文件（tail file），并将它们转发给Elasticsearch或Logstatsh进行索引、kafka等，Filebeat可以一次读取某个文件夹下的所有后缀名为log的文件，也可以读取指定的某一个后缀名为log的文件。

filebeat.yml文件配置，`paths：`指定要监控的日志，filebeat收集日志后发往logstash，配置如下：

```shell
filebeat:
  prospectors:
    - input_type: log
      paths:  # 这里是容器内的path  和nginx的log挂载同一目录
          - /tmp/access.log
      tags: ["nginx-access"]
  registry_file: /usr/share/filebeat/data/registry/registry  # 这个文件记录日志读取的位置，如果容器重启，可以从记录的位置开始取日志

output:
  logstash:  
    hosts: ["logstash:5044"] 
```

如果是海量数据，可以选择推到Kafka，而不是直接推到Logstatsh。

#### Logstatsh

可以设置对日志进行过滤。

```shell
input {
  beats {
    port => 5044
    codec => json
    client_inactivity_timeout => 36000
  }
}
filter {

if 'nginx-access' in [tags]{

  grok {
        match =>{ 
          "message" => "^%{IPV4:remote_addr} \[%{HTTPDATE:timestamp}\] \"%{WORD:verb} %{DATA:request} HTTP/%{NUMBER:httpversion}\" %{INT:status} %{INT:body_bytes_sent} \"%{NOTSPACE:http_referer}\" %{NUMBER:request_time} \"%{IPV4:upstream_addr}:%{POSINT:upstream_port}\" %{NUMBER:upstream_response_time} \"%{DATA:http_user_agent}\" \"%{NOTSPACE:http_x_forwarded_for}\""
          }
        remove_field => ["message"]   
    }
	
}
      
}
output {
  elasticsearch {
    hosts => ["elasticsearch:9200"] #  elasticsearch docker
    index => "wwfmac-nginx"
  }
}
```

##### ElasticSearch

将Logstash消费的数据推送到ElasticSearch

```javascript

```



## egg

后台服务使用egg开发，首先定时从ElasticSearch获取原始日志数据，存储到MySQL数据库。再利用定时任务，按照不同的时间周期，对入库的数据进行计算存储。

egg读取ElasticSearch，安装 `egg-es` 依赖

```js
// config.js 配置
 exports.elasticsearch = {
    host: 'http://118.190.245.148:9200',
    apiVersion: '7.x'
  };
```

```js
// pulgin.js 中配置
exports.elasticsearch = {
  enable: true,
  package: 'egg-es', 
};
```

```js
  async queryES(query = { match_all: {} }) {
    // 相关文档：https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/7.x/search_examples.html
    // const ctx = this.ctx
    let result = await this.app.elasticsearch.search({
      index: ES_INDEX, // es索引
      size: 200,
      sort: ['@timestamp:asc'], //按时间戳降序排序 
      body: {
        query: query
        //   match: {
        //   }
      }
    });
    const arr = result.hits.hits;
    return arr;
  }
}
```



### 使用file

eggjs  编写上传入口   

使用log4js 或存入本地日志文件

方案二   logserve 服务器

## 数据架构 清洗

采集端 接入层 NGINX 处理层：Node  Kafka 离线任务   DB：mongoDB MySQL   管理端Admin

参考宋小菜  ES方案，kafka，kafka替代方案Redis/RabbitMQ

ES：获取数据 数据预处理 数据聚合

两种削峰机制：每分钟数据获取上线10000条，超过就采样入库



同一终端同类型错误数量大于200条（可配置），只取200条，或者只统计数量，预先处理最新的错误

预处理

webviewSDKScriptError   提取有用信息，删除无用信息，

数据聚合 

优化存储空间，优化查询性能，从多个维度来做决，业务名，错误类型；错误信息，md5是否一样（排除同一种错误的不同特性信息，不同系统版本的差异信息），统一错误合并（记录最早的时间，最后的时间，次数

清洗过程监控 数据量和耗时，忽略的数据，每分钟拉取数据量

## 数据分析



数据提取阿里云的LOG Service，他能够提供给日志的实时消费接口，查询手段丰富，能够添加索引。

### 异常分析

stack 信息里得出原因，错误行方法名，层层调用的方法名和文件行数

堆栈信息，第一行第一列，浏览器的匿名函数(即 anonymous)中执行的代码，类似直接打在 console 中的代码，或者通过 `eval` 等函数运行的代码

UA用来区分页面所在的坏境

#### sourceMap

webPack插件实现SourceMap上传，创建上传插件，加载上传插件，添加读取sourceMap读取逻辑

实现http上传，到监控服务器，服务器端添加上传接口

解析ErrorStack   单独创建一个用以解析的js，并且船舰测试文件。

##### 反序列Error对象

创建一个新的Error对象，将错误栈设置到Error中，然后利用error-stack-parse这个库来转化为stackFrame

##### 解析ErrorStack

##### 将源码位置记入日志

将错误代码中的代码位置转换为源码位置

辅助错误分析

记录前端额Ajax请求，点击事件，以及控制台错误日志，当发生错误是，会把这些行为日志和错误日志关联起来，以更好的分析错误的原因。

客户端建立行为日志链路，启动，页面跳转，网络坏境变化，错误请求,uuid生成链路id

### 问题定位

#### 优秀实践

##### sourceMap映射

手动映射  ：生成结果不稳定，本地生成的和线上版本不一致。 SourceMap生成慢，浪费时间；SourceMap的检索和管理；不便于分享；无法与其他辅助信息结合

##### 自动构建

开启SourceMap的问题，构建耗时长，影响构建效率；容易出现构建异常，影响发布。

SourceMap异步生成

在不同的机器上进行构建，需要锁定依赖树，防止依赖不一致导致的构建产物不一致。

保存到只有内网能访问的vpn上，便于监控平台获取。

##### 堆栈上报优化（这种方案在上报的时候优化，还可以在从logService/redis数据清洗的时候优化）

堆栈文本量大，重复上报无意义，使用堆栈压缩，防止重复。

堆栈压缩：URL替换成标识符

防止重复：堆栈归一，指纹提取，生成id

（SDK是否开启堆栈压缩，默认为true，用于在不同的地方处理数据）

是否已有探测，普通量级接口探测，大量级服务端接收到某个堆栈后，往CDN发送一个带有堆栈ID的空文件。

##### 平台映射

npm上的source-map

##### 数据分析

借助坏境信息分析错误

##### 关注操作

相对于录屏的复杂难度，可以记录错误前的剂不操作，有埋点系统的，可以将错误和埋点数据关联起来。

关注变更

代码发版 依赖的App发版 依赖版本更新

#### 钉钉

应用名 和 应用版本

长尾错误，错误以及修改了，但用户没有更新（离线包情况）

支持短时关闭，和错误过滤（过滤要在上报层，清洗层，干掉？！）白名单过滤，黑名单过滤

日志双写，一路拿去做存储，一路拿去做报警  过滤jsbdrign



## 监控面板系统

### 数据查看

实时PV/UV查看

实时错误查看

贝贝----

监控平台可视化    

三块需求， 趋势包含全部错误趋势和聚合后的错误趋势

| 错误列表 | 可检索   | 可拍续   | 错误信息 |        |
| -------- | -------- | -------- | -------- | ------ |
| 错误详情 | 错误堆栈 | 用户行为 | 特征信息 | 可检索 |
| 趋势     | 错误趋势 | 事件趋势 |          |        |

页面规划

| 错误列表页 | 错误趋势                              | 检索区域 （多条件检索） | 错误列表（各维度拍续：错误数，错误用户数，时间排序，24小时内新增错误按时间排序） |          |                                             |
| ---------- | ------------------------------------- | ----------------------- | ------------------------------------------------------------ | -------- | ------------------------------------------- |
| 错误详情页 | 检索区域（时间 版本等简单的检索条件） | 事件趋势                | 事件信息                                                     | 特征信息 | 事件列表 聚合错误后错误的每一个具体错误事件 |

上报事件与发生时间的取舍，以及使用各种方案的解决办法；

清洗任务较慢，可能影响告警，导致达不到阈值。可以先获取到原始错误数量，先告警，再不全清洗后的错误信息。

#### 报警系统

（宋小菜） https://www.yuque.com/zaotalk/posts/rib0iz#vd70O

报警任务查看和编辑，设置几分钟内不再报警

issu处理 

列表

详情

更新日志

错误处理记录

统一错误结构的错误信息，然后据此判断和归类错误，

JS错误参考字段包括

- 错误类型：TypeError SyntaxError等；
- ErrorMessage：即错误信息
- 触发函数 onerror/unhandledrejection
- 堆栈信息

**错误采集附带坏境信息，错误列表显示坏境信息** ——贝贝

连续M分钟，每分钟错误量大于等于N，（M、N可配置）满足条件

自定义告警方式可拓展，钉钉，邮箱（普通告警），电话，短信，webhook，

标题：告警来源+错误灯即+业务

内容：错误描述+影响多少用户

**雨燕**

报错信息中包含上报数和影响用户数，异常信息可以添加到忽略和关注列表，忽略的异常不会再计入累计数据。

错误详情： 页面 URL  操作系统 终端设备 浏览器 容器版本 离线包版本 区域

报警规则列表   报警规则设置

系统报警  默认提供的报警，常用于新报错

智能报警 :算法智能探测异常突然升高

规则报警：用户自己设置的规则报警，比如监控某个页面， 报警对象（监控项，条件 》= all）触发条件： 报警灯即（告警，普通邮件，高级钉钉电话），静默期

点开报警规则，看到报警记录，具体报错数，报错前的异常趋势

## 性能优化

警报系统



日志数据定期清除，或存储至OSS，定时任务筛选数据存储到数据库中，过期的日志不再提供查询

上报降级方案，当数据井喷，前端自动调整采样率，后端自动放弃一些数据

**ElasticSearch**

## 参考资料

腾讯aegis https://mp.weixin.qq.com/s/aqO55IyVCZzh9yhKuOKSCQ

开课吧老师 https://juejin.im/post/5e8ec2cf518825739208e249

JS错误处理和函数调用栈堆栈追踪  https://github.com/dwqs/blog/issues/49  console.trace()

开源框架

Fundebug 免费付费版，不支持Weex

Sentry 不支持Weex 小程序，稳定性不好

Bugly 仅仅支持Android和iOS，以及一些游戏框架（Cocos2d Unity3D），不支持扩展，Weex仅有简单信息

FrontJS 仅支持Web端和小程序，每分钟事件受限（高级版），告警通知受限，不支持拓展

Fee 开源

badjs 开源

bugsnag



宋小菜



![image.png](https://cdn.nlark.com/yuque/0/2020/png/88660/1587822119486-acd2c6a2-39ea-432c-8dea-96f0965cf5d5.png?x-oss-process=image%2Fresize%2Cw_1492)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/88660/1587826888446-43ef6c20-ca4d-4ea1-a563-6a46094f35f8.png?x-oss-process=image%2Fresize%2Cw_1492)



贝贝  https://www.yuque.com/zaotalk/posts/mxx4cb

![image-20200620173632990](C:\Users\ding\AppData\Roaming\Typora\typora-user-images\image-20200620173632990.png)

node端SDK

雨燕

自动脚本接入  自动判断问题的严重程度  更智能的警报，减少误报率。异常自愈

钉钉

dunfire

iTrace UC出品 阿里内部

### badjs-report

